{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Limulator Docs","title":"Welcome to Limulator Docs"},{"location":"#welcome-to-limulator-docs","text":"","title":"Welcome to Limulator Docs"},{"location":"SUMMARY/","text":"Getting Started Tutorials System Documentation Module Documentation Laser Module Camera Module Platform Module UI Server Processing Others References","title":"SUMMARY"},{"location":"references/","text":"References Lidar Basics Blender For Blender Python API documentation visit Blender Python API Simulation Basics","title":"References"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#lidar-basics","text":"","title":"Lidar Basics"},{"location":"references/#blender","text":"For Blender Python API documentation visit Blender Python API","title":"Blender"},{"location":"references/#simulation-basics","text":"","title":"Simulation Basics"},{"location":"startup/","text":"Getting Started Download Installation Windows Linux First Run","title":"Getting Started"},{"location":"startup/#getting-started","text":"","title":"Getting Started"},{"location":"startup/#download","text":"","title":"Download"},{"location":"startup/#installation","text":"","title":"Installation"},{"location":"startup/#windows","text":"","title":"Windows"},{"location":"startup/#linux","text":"","title":"Linux"},{"location":"startup/#first-run","text":"","title":"First Run"},{"location":"system_doc/","text":"Class Diagram Process Diagram","title":"System Documentation"},{"location":"system_doc/#class-diagram","text":"","title":"Class Diagram"},{"location":"system_doc/#process-diagram","text":"","title":"Process Diagram"},{"location":"tutorials/","text":"","title":"Tutorials"},{"location":"video/","text":"Video example Lorem ipsum dolor sit amet","title":"Video example"},{"location":"video/#video-example","text":"Lorem ipsum dolor sit amet","title":"Video example"},{"location":"modules/camera/","text":"Camera Module camera Camera class. It lets create and render images based on the camera paeameters Attributes: Name Type Description camera_data json camera data Source code in Modules\\camera.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class camera : \"\"\"Camera class. It lets create and render images based on the camera paeameters Attributes: camera_data (json): camera data platform_data camera_name fps outfile_location focal_length x_resolution y_resolution start_frame end_frame \"\"\" def __init__ ( self , camera_data : json , platform_data : json , sensor_data : json ) -> None : \"\"\" Initialize a Camera class. Get all camera parameters Args: camera_data: camera data platform_data: Platform data sensor_data: Sensor Data \"\"\" self . camera_data = camera_data self . platform_data = platform_data self . camera_name = camera_data [ \"camera_name\" ] self . fps = self . camera_data [ 'fps' ] self . outfile_location = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/camera/\" + self . camera_name + \"_\" self . focal_length = self . camera_data [ \"focal_length\" ] self . x_resolution = self . camera_data [ \"resolution\" ][ \"x\" ] self . y_resolution = self . camera_data [ \"resolution\" ][ \"y\" ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] # Calculate camera framescale based on Lidar Sensor PRF, number of channels and Camera FPS self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . camera_framescale = int ( self . prf / ( camera_data [ 'fps' ] * self . number_of_channels )) self . frames_list = np . arange ( self . start_frame , self . end_frame , self . camera_framescale ) self . create_camera () def create_camera ( self ): \"\"\" Creates a blender camera object inside empty camera object \"\"\" # Create an camera object camera_data = bpy . data . cameras . new ( name = 'Camera' ) self . camera_object = bpy . data . objects . new ( 'Camera' , camera_data ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . camera_object ) camera_parent_obj = bpy . data . objects [ self . camera_name ] self . camera_object . parent = camera_parent_obj bpy . context . scene . camera = self . camera_object # Set camera focal length and resolution self . camera_object . data . lens = self . focal_length bpy . context . scene . render . resolution_x = self . x_resolution bpy . context . scene . render . resolution_y = self . y_resolution def render_frames ( self ): \"\"\" Renders frames for the full scene with the selected camera \"\"\" logger . update_progress ( \"Generating Camera Images\" , 0 ) bpy . context . scene . render . image_settings . file_format = 'PNG' for frame in range ( len ( self . frames_list )): i = self . frames_list [ frame ] logger . update_progress ( \"Generating Camera Images\" , frame / len ( self . frames_list )) bpy . context . scene . frame_set ( i ) bpy . context . scene . render . filepath = self . outfile_location + str ( i ) + \".png\" bpy . ops . render . render ( write_still = True ) logger . update_progress ( \"Generating Camera Images\" , 1 ) __init__ ( camera_data , platform_data , sensor_data ) Initialize a Camera class. Get all camera parameters Parameters: Name Type Description Default camera_data json camera data required platform_data json Platform data required sensor_data json Sensor Data required Source code in Modules\\camera.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , camera_data : json , platform_data : json , sensor_data : json ) -> None : \"\"\" Initialize a Camera class. Get all camera parameters Args: camera_data: camera data platform_data: Platform data sensor_data: Sensor Data \"\"\" self . camera_data = camera_data self . platform_data = platform_data self . camera_name = camera_data [ \"camera_name\" ] self . fps = self . camera_data [ 'fps' ] self . outfile_location = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/camera/\" + self . camera_name + \"_\" self . focal_length = self . camera_data [ \"focal_length\" ] self . x_resolution = self . camera_data [ \"resolution\" ][ \"x\" ] self . y_resolution = self . camera_data [ \"resolution\" ][ \"y\" ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] # Calculate camera framescale based on Lidar Sensor PRF, number of channels and Camera FPS self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . camera_framescale = int ( self . prf / ( camera_data [ 'fps' ] * self . number_of_channels )) self . frames_list = np . arange ( self . start_frame , self . end_frame , self . camera_framescale ) self . create_camera () create_camera () Creates a blender camera object inside empty camera object Source code in Modules\\camera.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def create_camera ( self ): \"\"\" Creates a blender camera object inside empty camera object \"\"\" # Create an camera object camera_data = bpy . data . cameras . new ( name = 'Camera' ) self . camera_object = bpy . data . objects . new ( 'Camera' , camera_data ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . camera_object ) camera_parent_obj = bpy . data . objects [ self . camera_name ] self . camera_object . parent = camera_parent_obj bpy . context . scene . camera = self . camera_object # Set camera focal length and resolution self . camera_object . data . lens = self . focal_length bpy . context . scene . render . resolution_x = self . x_resolution bpy . context . scene . render . resolution_y = self . y_resolution render_frames () Renders frames for the full scene with the selected camera Source code in Modules\\camera.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def render_frames ( self ): \"\"\" Renders frames for the full scene with the selected camera \"\"\" logger . update_progress ( \"Generating Camera Images\" , 0 ) bpy . context . scene . render . image_settings . file_format = 'PNG' for frame in range ( len ( self . frames_list )): i = self . frames_list [ frame ] logger . update_progress ( \"Generating Camera Images\" , frame / len ( self . frames_list )) bpy . context . scene . frame_set ( i ) bpy . context . scene . render . filepath = self . outfile_location + str ( i ) + \".png\" bpy . ops . render . render ( write_still = True ) logger . update_progress ( \"Generating Camera Images\" , 1 )","title":"Camera Module"},{"location":"modules/camera/#camera-module","text":"","title":"Camera Module"},{"location":"modules/camera/#Modules.camera.camera","text":"Camera class. It lets create and render images based on the camera paeameters Attributes: Name Type Description camera_data json camera data Source code in Modules\\camera.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class camera : \"\"\"Camera class. It lets create and render images based on the camera paeameters Attributes: camera_data (json): camera data platform_data camera_name fps outfile_location focal_length x_resolution y_resolution start_frame end_frame \"\"\" def __init__ ( self , camera_data : json , platform_data : json , sensor_data : json ) -> None : \"\"\" Initialize a Camera class. Get all camera parameters Args: camera_data: camera data platform_data: Platform data sensor_data: Sensor Data \"\"\" self . camera_data = camera_data self . platform_data = platform_data self . camera_name = camera_data [ \"camera_name\" ] self . fps = self . camera_data [ 'fps' ] self . outfile_location = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/camera/\" + self . camera_name + \"_\" self . focal_length = self . camera_data [ \"focal_length\" ] self . x_resolution = self . camera_data [ \"resolution\" ][ \"x\" ] self . y_resolution = self . camera_data [ \"resolution\" ][ \"y\" ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] # Calculate camera framescale based on Lidar Sensor PRF, number of channels and Camera FPS self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . camera_framescale = int ( self . prf / ( camera_data [ 'fps' ] * self . number_of_channels )) self . frames_list = np . arange ( self . start_frame , self . end_frame , self . camera_framescale ) self . create_camera () def create_camera ( self ): \"\"\" Creates a blender camera object inside empty camera object \"\"\" # Create an camera object camera_data = bpy . data . cameras . new ( name = 'Camera' ) self . camera_object = bpy . data . objects . new ( 'Camera' , camera_data ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . camera_object ) camera_parent_obj = bpy . data . objects [ self . camera_name ] self . camera_object . parent = camera_parent_obj bpy . context . scene . camera = self . camera_object # Set camera focal length and resolution self . camera_object . data . lens = self . focal_length bpy . context . scene . render . resolution_x = self . x_resolution bpy . context . scene . render . resolution_y = self . y_resolution def render_frames ( self ): \"\"\" Renders frames for the full scene with the selected camera \"\"\" logger . update_progress ( \"Generating Camera Images\" , 0 ) bpy . context . scene . render . image_settings . file_format = 'PNG' for frame in range ( len ( self . frames_list )): i = self . frames_list [ frame ] logger . update_progress ( \"Generating Camera Images\" , frame / len ( self . frames_list )) bpy . context . scene . frame_set ( i ) bpy . context . scene . render . filepath = self . outfile_location + str ( i ) + \".png\" bpy . ops . render . render ( write_still = True ) logger . update_progress ( \"Generating Camera Images\" , 1 )","title":"camera"},{"location":"modules/camera/#Modules.camera.camera.__init__","text":"Initialize a Camera class. Get all camera parameters Parameters: Name Type Description Default camera_data json camera data required platform_data json Platform data required sensor_data json Sensor Data required Source code in Modules\\camera.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , camera_data : json , platform_data : json , sensor_data : json ) -> None : \"\"\" Initialize a Camera class. Get all camera parameters Args: camera_data: camera data platform_data: Platform data sensor_data: Sensor Data \"\"\" self . camera_data = camera_data self . platform_data = platform_data self . camera_name = camera_data [ \"camera_name\" ] self . fps = self . camera_data [ 'fps' ] self . outfile_location = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/camera/\" + self . camera_name + \"_\" self . focal_length = self . camera_data [ \"focal_length\" ] self . x_resolution = self . camera_data [ \"resolution\" ][ \"x\" ] self . y_resolution = self . camera_data [ \"resolution\" ][ \"y\" ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] # Calculate camera framescale based on Lidar Sensor PRF, number of channels and Camera FPS self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . camera_framescale = int ( self . prf / ( camera_data [ 'fps' ] * self . number_of_channels )) self . frames_list = np . arange ( self . start_frame , self . end_frame , self . camera_framescale ) self . create_camera ()","title":"__init__()"},{"location":"modules/camera/#Modules.camera.camera.create_camera","text":"Creates a blender camera object inside empty camera object Source code in Modules\\camera.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def create_camera ( self ): \"\"\" Creates a blender camera object inside empty camera object \"\"\" # Create an camera object camera_data = bpy . data . cameras . new ( name = 'Camera' ) self . camera_object = bpy . data . objects . new ( 'Camera' , camera_data ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . camera_object ) camera_parent_obj = bpy . data . objects [ self . camera_name ] self . camera_object . parent = camera_parent_obj bpy . context . scene . camera = self . camera_object # Set camera focal length and resolution self . camera_object . data . lens = self . focal_length bpy . context . scene . render . resolution_x = self . x_resolution bpy . context . scene . render . resolution_y = self . y_resolution","title":"create_camera()"},{"location":"modules/camera/#Modules.camera.camera.render_frames","text":"Renders frames for the full scene with the selected camera Source code in Modules\\camera.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def render_frames ( self ): \"\"\" Renders frames for the full scene with the selected camera \"\"\" logger . update_progress ( \"Generating Camera Images\" , 0 ) bpy . context . scene . render . image_settings . file_format = 'PNG' for frame in range ( len ( self . frames_list )): i = self . frames_list [ frame ] logger . update_progress ( \"Generating Camera Images\" , frame / len ( self . frames_list )) bpy . context . scene . frame_set ( i ) bpy . context . scene . render . filepath = self . outfile_location + str ( i ) + \".png\" bpy . ops . render . render ( write_still = True ) logger . update_progress ( \"Generating Camera Images\" , 1 )","title":"render_frames()"},{"location":"modules/laser/","text":"Laser Module laser_sensor Creates a laser sensor object with the provided sensor data Attributes: Name Type Description platform_data dict platform_data sensor_data dict sensor_data start_frame int First frame number to start rendering from end_frame int Last frame number to end rendering at prf int Pulse Repetition Frequency sf int Scanning Frequency rotation_type str Type of rotation csv_export_list list List containing all the intersection points data_accuracy int Set last decimal place upto which all data needs to be rounded off data_columns list List of header names of the exported csv file time_per_horizontal_dev float Time interval in seconds between each deviation deviation_per_frame float Angle of deviation between each frame (in degree) dict_data dict A dictionary containing labels and their respective id's dict_keys list List of label id dict_values list List of label names start_vfov float Start of vertical frame of view end_vfov float End of vertical field of view positive_hfov float Start of horizontal feild of view negative_hfov float End of horizontal feild of view flying_height int Mean flying height for rotating polygon type sensor frame_step int The number of frames to process before exporting hfov float Horizontal Field of view horizontal_deviation_per_pulse float Angle of deviation between each horizontal channel (in degree) laser_list list List containg names of all laserline objects laser_origin_orientation_list list List containing orientation values at each frame laser_step int The number of laser lines to process before exporting number_of_channels int Number of vertical channels number_of_hor_channels int Number of horizontal channels out_file_name str File path of the output file name preinitialized_frame bool preinitialized_frame pulses_per_frame int Number of pulses emitted at each frame rotation_type str Rotation type of the lidar sensor scanner_location list Scanner's location in the platform's local coordinate system [x,y,z] sensor_name str Sensor's name sensor_range_max int Maximum range of sensor sensor_range_min int Minimum range of sensor fixed_error_model list List containing lists of randomly generated error values for x, y and z model_range list List of all range values between sensor_range_max and sensor_range_min range_error_model array range_error_model incidence_angle_error_model array incidence_angle_error_model Source code in Modules\\laser.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 class laser_sensor : \"\"\"Creates a laser sensor object with the provided sensor data Attributes: platform_data (dict): platform_data sensor_data (dict): sensor_data start_frame (int): First frame number to start rendering from end_frame (int): Last frame number to end rendering at prf (int): Pulse Repetition Frequency sf (int): Scanning Frequency rotation_type (str): Type of rotation csv_export_list (list): List containing all the intersection points data_accuracy (int): Set last decimal place upto which all data needs to be rounded off data_columns (list): List of header names of the exported csv file time_per_horizontal_dev (float): Time interval in seconds between each deviation deviation_per_frame (float): Angle of deviation between each frame (in degree) dict_data (dict): A dictionary containing labels and their respective id's dict_keys (list): List of label id dict_values (list): List of label names start_vfov (float): Start of vertical frame of view end_vfov (float): End of vertical field of view positive_hfov (float): Start of horizontal feild of view negative_hfov (float): End of horizontal feild of view flying_height (int): Mean flying height for rotating polygon type sensor frame_step (int): The number of frames to process before exporting hfov (float): Horizontal Field of view horizontal_deviation_per_pulse (float): Angle of deviation between each horizontal channel (in degree) laser_list (list): List containg names of all laserline objects laser_origin_orientation_list (list): List containing orientation values at each frame laser_step (int): The number of laser lines to process before exporting number_of_channels (int): Number of vertical channels number_of_hor_channels (int): Number of horizontal channels out_file_name (str): File path of the output file name preinitialized_frame (bool): preinitialized_frame pulses_per_frame (int): Number of pulses emitted at each frame rotation_type (str): Rotation type of the lidar sensor scanner_location (list): Scanner's location in the platform's local coordinate system [x,y,z] sensor_name (str): Sensor's name sensor_range_max (int): Maximum range of sensor sensor_range_min (int): Minimum range of sensor fixed_error_model (list): List containing lists of randomly generated error values for x, y and z model_range (list): List of all range values between sensor_range_max and sensor_range_min range_error_model (array): range_error_model incidence_angle_error_model (array): incidence_angle_error_model \"\"\" def __init__ ( self , sensor_data : json , platform_data : json ) -> None : \"\"\" Initialises all the variables. Calls model accuracy which creates error models for `range`, `incidence` and `fixed errors`. `laser_origin_orientation_list` is created which provides sensor orientation values (omega, phi and kappa) for each frame. Args: sensor_data: all parameters of the sensor platform_data: all platform parameters \"\"\" self . laser_step = 100 #: int: The number of laser lines to process before exporting self . frame_step = 50 #: int: The number of frames to process before exporting self . data_accuracy = 8 #: int: Set last decimal place upto which all data needs to be rounded off self . sensor_data = sensor_data #: json: Get all sensor parameters self . platform_data = platform_data #: json: Get all platform parameters self . sensor_name = self . sensor_data [ \"sensor_name\" ] #: str: Sensor's name self . rotation_type = self . sensor_data [ \"rotation_type\" ] self . scanner_location = self . sensor_data [ \"platform\" ][ \"position\" ] try : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] except : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . sf = sensor_data [ \"parameters\" ][ \"sf\" ] self . start_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"start_fov\" ] self . end_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"end_fov\" ] self . positive_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"start_view_angle\" ] self . negative_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"end_view_angle\" ] self . sensor_range_min = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'min' ] self . sensor_range_max = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'max' ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] self . hfov = self . negative_hfov - self . positive_hfov # Calculate horizontal field of view self . horizontal_deviation_per_pulse = self . sf * self . hfov * self . number_of_channels / self . prf # Calculate horizontal deviation per pulse self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation self . out_file_name = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/Sensor/point_cloud_\" + self . sensor_name + \".csv\" # Set output csv file name #: Initialize lists for error models self . fixed_error_model = [] self . model_range = [] self . range_error_model = [] self . incidence_angle_error_model = [] self . model_accuracy () # Create error models based on selection # Create sensor origin orientation list for each frame for each scanning pattern type self . laser_origin_orientation_list = [] if self . rotation_type == \"rotating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_r () if self . rotation_type == \"osscilating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_o () if self . rotation_type == \"rotating_polygon\" : self . flying_height = self . sensor_data [ 'parameters' ][ 'horizontal_scanning' ][ 'mean_flying_height' ] self . orientation_csv_static_not_rotating () if self . rotation_type == \"flash\" : self . number_of_hor_channels = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] self . orientation_csv_static_not_rotating () self . laser_list = [] #List containing names of laser objects self . data_columns = [ \"//X\" , \"Y\" , \"Z\" , \"Time\" , \"Label\" , \"Instance_id\" , \"Incidence_angle\" , \"Sensor_name\" , \"Pulse_id\" , \"Channel_id\" , \"Rf\" , \"Gf\" , \"Bf\" , \"Af\" , \"Intensity\" ] #List of header names for exported csv file self . csv_export_list = [] #List containing interected points # Get all label values self . dict_data = global_data . bl_scene . label_dict self . dict_values = list ( self . dict_data . values ()) self . dict_keys = list ( self . dict_data . keys ()) global_data . bl_scene . all_data [ 'labels' ] = self . dict_data self . preinitialized_frame = False def lidar_sensor_main ( self ) -> None : \"\"\"Main class to handle creation of sensor frame and to check intersections\"\"\" bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects global_data . bl_scene . all_data [ \"time\" ] = 0 export_json ( True ) # Export json file starttime = time . time () #Start time self . create_export_file () # Create output csv file with headers # Based on sensor type - create a sensor frame, then iterate over the previously create orientation list if self . rotation_type == \"rotating_polygon\" or self . rotation_type == \"flash\" : self . create_sensor_frame () self . rotating_polygon_iterator () if self . rotation_type == \"osscilating\" or self . rotation_type == \"rotating\" : self . preinitialized_frame = True self . create_sensor_frame () self . all_laserlines_frame_range_iterator ( self . start_frame , self . end_frame ) endtime = time . time () #End time global_data . bl_scene . all_data [ \"time\" ] = endtime - starttime export_json ( True ) # Export json file bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects for next run def visulize_sensor_frame ( self ) -> None : \"\"\"Visulises the sensor frame \"\"\" self . preinitialized_frame = True self . create_sensor_frame () def model_accuracy ( self ) -> None : \"\"\"Generates a accuracy model based on the error type \"\"\" if ( \"fixed\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Genrates a list of random errors based on the standard dev values from user try : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'x' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'y' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] except : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] self . fixed_error_model = [ np . random . normal ( loc = 0 , scale = float ( fixed_error_x ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_y ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_z ), size = 10000 )] if ( \"range\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree range vs accuracy curve self . model_range = np . linspace ( self . sensor_range_min , self . sensor_range_max , self . sensor_range_max , dtype = int ) range_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a1' ] # User input for coefficient of x^2 range_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a2' ] # User input for coefficient of x range_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a3' ] # User input for error at minimum range self . range_error_model = ( range_a1 * ( self . model_range ** 2 )) + ( range_a2 * self . model_range ) + range_a3 if ( \"incidence\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree incidence angle vs accuracy curve min_incidence_angle = 0 max_incidence_angle = 1.58 step = 0.01 self . model_incidence_angle = np . arange ( min_incidence_angle , max_incidence_angle , step ) incidence_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a1' ] # User input for coefficient of x^2 incidence_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a2' ] # User input for coefficient of x incidence_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a3' ] # User input for error at minimum range self . incidence_angle_error_model = ( incidence_a1 * ( self . model_incidence_angle ** 2 )) + ( incidence_a2 * self . model_incidence_angle ) + incidence_a3 def get_fixed_error ( self ) -> list : \"\"\"Returns a random error value from the fixed error model Returns: [error in x, error in y, error in z] \"\"\" error_x = random . choices ( self . fixed_error_model [ 0 ], k = 1 )[ 0 ] error_y = random . choices ( self . fixed_error_model [ 1 ], k = 1 )[ 0 ] error_z = random . choices ( self . fixed_error_model [ 2 ], k = 1 )[ 0 ] return [ error_x , error_y , error_z ] def get_range_error ( self , range : float ) -> np . ndarray : \"\"\"Returns a list of random values based on input `range` Generates random error from a normal distribution with a standard deviation for the given `range` from `range_error_model` Args: range:Range at which the point exists Returns: Error in range \"\"\" try : accuracy_at_range = self . range_error_model [ np . where ( self . model_range == int ( range ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_range = 0 range_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_range ), size = 1 )[ 0 ] # Computed range error return range_error def get_incidence_error ( self , angle : float ) -> np . ndarray : \"\"\"Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: List of errors for x, y, z - list(error in x, error in y, error in z) \"\"\" try : accuracy_at_angle = self . incidence_angle_error_model [ np . where ( self . model_incidence_angle == int ( angle ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_angle = 0 indicence_angle_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_angle ), size = 1 )[ 0 ] # Computed error list return indicence_angle_error def get_horizontal_deviation_angles ( self ) -> np . ndarray : \"\"\" Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Numpy list of angles of deviation for each laser line \"\"\" # For Rotatind and Osscilating if self . rotation_type == \"rotating\" or self . rotation_type == \"osscilating\" : angle_list = np . array ([ 0 ]) # For Flash if self . rotation_type == \"flash\" : angle_dev = ( self . negative_hfov - self . positive_hfov ) / ( self . number_of_hor_channels - 1 ) angle_list = np . arange ( self . positive_hfov , self . negative_hfov + 1 , angle_dev ) # For Rotating polygon style if self . rotation_type == \"rotating_polygon\" : angle_sublist = [ 0 ] #print (self.flying_height,math.tan(math.radians(self.hfov)),self.sf,self.prf) ground_spacing = self . flying_height * math . tan ( math . radians ( self . hfov )) * self . sf / self . prf # Calculate ground spacing if ( np . sign ( self . negative_hfov ) != np . sign ( self . positive_hfov )): for angle in [ math . radians ( self . negative_hfov ), math . radians ( self . positive_hfov )]: swath_width = self . flying_height * math . tan ( abs ( angle )) # Calculate Swath width n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( n * ground_spacing ) / self . flying_height )) ) * ( angle / abs ( angle )) #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) else : sign = ( self . negative_hfov / self . positive_hfov ) / abs (( self . negative_hfov / self . positive_hfov )) signed_hfov = abs ( math . radians ( self . negative_hfov ) - math . radians ( self . positive_hfov )) * ( sign ) swath_width = self . flying_height * math . tan ( abs ( signed_hfov )) initial_angle = min ( abs ( math . radians ( self . negative_hfov )), abs ( math . radians ( self . positive_hfov ))) initial_width = self . flying_height * math . tan ( abs ( initial_angle )) n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( initial_width + ( n * ground_spacing )) / self . flying_height )) ) * sign #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) angle_list = np . unique ( np . array ( angle_sublist ) . flatten ()) # Rearrange array and remove duplicate angle values return angle_list def orientation_csv_static_r ( self ): \"\"\"Generates a list for orientation values for a rotating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = ( i * self . deviation_per_frame ) + self . positive_hfov if ( dev_angle % 360 < self . negative_hfov ): dev_angle = dev_angle % 360 self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) else : self . laser_origin_orientation_list . append ([ i , \"skip\" , \"skip\" , \"skip\" ]) # Skip laser line generation while out of FOV self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def orientation_csv_static_o ( self ): \"\"\"Generates a list for orientation values for a Osscilating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = i * self . deviation_per_frame if int ( dev_angle / self . hfov ) % 2 == 0 : dev_angle = dev_angle % self . hfov else : dev_angle = self . hfov - ( dev_angle % self . hfov ) dev_angle += self . positive_hfov self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def orientation_csv_static_not_rotating ( self ): \"\"\"Creates a positition orientation list for a stationary non rotating type of scanner \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): self . laser_origin_orientation_list . append ([ i , 0 , 0 , 0 ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def create_sensor_frame ( self ): \"\"\"Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV \"\"\" lidar_sensor_main = bpy . data . objects [ self . sensor_name ] # Get blender object with the given sensor name try : vertical_deviation = ( self . end_vfov - self . start_vfov ) / ( self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] - 1 ) # Deviation between each vertical channel vertical_deviations = np . arange ( self . start_vfov , self . end_vfov + 1 , vertical_deviation ) . tolist () # List of angle of deviation for each vertical channel except : vertical_deviations = [ 0.0 ] # Deviation for a single channel sensor horizontal_deviations = self . get_horizontal_deviation_angles () # Get a list of angle of deviation for each horizontal channel if self . rotation_type == \"rotating_polygon\" : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * len ( horizontal_deviations ) self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation for pulse in range ( len ( horizontal_deviations )): h_dev_angle = horizontal_deviations [ pulse ] # A deviation angle for current horizontal pulse for channel in range ( len ( vertical_deviations )): v_dev_angle = - vertical_deviations [ channel ] # A deviation angle for current vertical channel # Create a laser vector laser = bpy . data . objects . new ( \"laser_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) laser . empty_display_type = 'PLAIN_AXES' laser . empty_display_size = 0.001 laser . location = ( 0 , 0 , 0 ) # Create a laser direction vector l_dir = bpy . data . objects . new ( \"laser_dir_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) l_dir . empty_display_type = 'PLAIN_AXES' l_dir . empty_display_size = 0.001 direction_vector_length = 1 l_dir . location = ( direction_vector_length , 0 , 0 ) # Link the laser vector objects to the current scene if self . preinitialized_frame == True : bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( l_dir ) l_dir . parent = laser laser . parent = lidar_sensor_main # Link the laser vector object to the sensor object laser . rotation_euler = ( 0 , math . radians ( v_dev_angle ), math . radians ( h_dev_angle )) # Rotate the laser vector according the vertical and horizontal deviation self . laser_list . append ( self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel )) # Append the name of laser vector to the laser vector list bpy . context . view_layer . update () # Update blender scene context def get_label_id ( self , obj_name : string ) -> int : \"\"\"Returns label id based on the intersected object's name. * It looks for object_name in dict_values and returns its id from dict_keys. * If object name is not found in the label dictionary, id is set to 999 Args: obj_name: Object's Name Returns: Label id \"\"\" try : label_id = self . dict_values . index ( obj_name . lower ()) label = self . dict_keys [ label_id ] except : label = 999 return ( label ) def laserline_currentframe_interaction ( self , frame : int , selected_laserline_id : int ) -> list : \"\"\"Computes intersections for a selected laserline on the given frame Args: frame (int), selected_laserline_id (int) Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] \"\"\" bpy . context . view_layer . update () # Update blender context # Get laser origin and direction locations ray_origin = bpy . context . scene . objects [ \"laser_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () ray_direction_pt = bpy . context . scene . objects [ \"laser_dir_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () graph = bpy . context . evaluated_depsgraph_get () # Get scene context hit , location , normal , index , object , matrix , colour = self . check_intersection ( graph , ray_origin , ray_direction_pt - ray_origin , self . sensor_range_max ) # Get intersction point with RGBIR # Calculate Range incident_ray = location - ray_origin range = incident_ray . length if hit and range > self . sensor_range_min : # Check if intersection occured and range is greater than minimum range # Calculate Incidence Angle normal *= - 1 incidence_angle = incident_ray . rotation_difference ( normal ) . angle # Get error values range_error = self . get_range_error ( range ) incidence_error = self . get_incidence_error ( incidence_angle ) fixed_error_list = self . get_fixed_error () # Compute erronous incidence angle # Compute erronous range erronous_range = range + range_error # Compute new location unit_incident_ray = incident_ray / range updated_incident_ray = unit_incident_ray * erronous_range + ray_origin location = updated_incident_ray # Compute final position x = round ( location [ 0 ] + fixed_error_list [ 0 ], self . data_accuracy ) y = round ( location [ 1 ] + fixed_error_list [ 1 ], self . data_accuracy ) z = round ( location [ 2 ] + fixed_error_list [ 2 ], self . data_accuracy ) t = frame * self . time_per_horizontal_dev pulse_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 2 ]) channel_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 1 ]) r , g , b , a , ir = colour intensity = round ( ir * math . cos ( incidence_angle ) * 255 / ( range ** 2 ), self . data_accuracy ) label = str ( self . get_label_id ( object . name . split ( \".\" )[ 0 ])) try : instance_id = str ( object . name . split ( \".\" )[ 1 ]) except : instance_id = \"000\" #print (x,y,z) return ([ x , y , z , t , label , instance_id , incidence_angle , self . sensor_name , frame , channel_id , r , g , b , a , intensity ]) def check_intersection ( self , graph : bpy . context , origin : mathutils . Vector , direction : mathutils . Vector , distance : int ) -> Tuple [ Boolean , mathutils . Vector , mathutils . Vector , int , int , list , float , float , float , float , float ]: \"\"\" Finds out intersections for a laser vector starting from `origin` in the `direction`, upto the given `distance`. Note: It looks for intersection untill a point with zero transparency is found Args: graph: Blender scene context origin: Location of origin direction: Location of direction vector distance: Maximum range distance Returns: Returns a tuple of the following values hit location normal index object matrix r g b a ir \"\"\" r , g , b , a , ir = 0 , 0 , 0 , 0 , 0 location = mathutils . Vector (( 0 , 0 , 0 )) object , matrix , normal , index = None , None , None , None hit = True while ( a == 0 and hit ): # iterate until intersection occurs on an opaque object hit , location , normal , index , object , matrix = bpy . context . scene . ray_cast ( graph , origin = origin , direction = direction , distance = distance ) if hit : try : # Get RGB information from image texture mesh = object . data face = mesh . polygons [ index ] slot = object . material_slots [ face . material_index ] material = slot . material verticesIndices = face . vertices texture_image_name = material . node_tree . nodes [ 'Image Texture' ] . image . name # Transform 3D world location to 2D location on image plane p1 , p2 , p3 = [ object . matrix_world @ object . data . vertices [ verticesIndices [ i ]] . co for i in range ( 3 )] uvMapIndices = face . loop_indices uvMap = object . data . uv_layers [ 'UVMap' ] uv1 = [ uvMap . data [ uvMapIndices [ 0 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 0 ]] . uv [ 1 ], 0 ] uv2 = [ uvMap . data [ uvMapIndices [ 1 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 1 ]] . uv [ 1 ], 0 ] uv3 = [ uvMap . data [ uvMapIndices [ 2 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 2 ]] . uv [ 1 ], 0 ] transformed_location = mathutils . geometry . barycentric_transform ( location , p1 , p2 , p3 , uv1 , uv2 , uv3 ) #Get RGBA values from texture image img = bpy . data . images [ texture_image_name ] width , height = img . size [ 0 : 2 ] index = ((( int (( transformed_location [ 1 ] % 1 ) * height ) * width ) + int (( transformed_location [ 0 ] % 1 ) * width )) - 1 ) * 4 r , g , b , a = img . pixels [ index : index + 4 ] except : # Get RGB information from base colour material_layers = material . node_tree . nodes [ \"Principled BSDF\" ] . inputs r , g , b , a = material_layers [ 'Base Color' ] . default_value ir = ( r + g + b ) / ( 3 * 255 ) #IR value estimation # if a translucent object is found continue the ray ahead after the found point direction = location - origin distance = distance - direction . length origin = location + ( direction . normalized ()) direction = origin - location return ( hit , location , normal , index , object , matrix ,( r , g , b , a , ir )) def laser_object_group_frame_range_iterator ( self , start : int , end : int , laserline_id : int ) -> None : \"\"\"Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Args: start: Start frame end: End Frame laserline_id: Id of the selected laserline \"\"\" bpy . context . view_layer . update () # Update blender context csv_export_list = [] #Empty list to store the intersection data steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame # Set frame frame = int ( self . laser_origin_orientation_list [ frame_number - start ][ 0 ]) bpy . context . scene . frame_set ( frame ) for selected_laserline_id in range ( laserline_id , laserline_id + self . laser_step ): #iterate through laser line group if self . laserline_currentframe_interaction ( frame , selected_laserline_id ): csv_export_list . append ( self . laserline_currentframe_interaction ( frame , selected_laserline_id )) # Append data to export list if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Append data to csv file def all_laserlines_frame_range_iterator ( self , start : int , end : int ): \"\"\"Computes intersections for all channels across a given frame range and exports the data to csv file Args: start: Start frame end: End Frame \"\"\" steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): csv_export_list = [] #Empty list to store the intersection data start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame #print (start_frame,end_frame,frame_number) # Set blender scene frame frame = int ( self . laser_origin_orientation_list [ frame_number ][ 0 ]) #print (frame) orientation = self . laser_origin_orientation_list [ frame_number ][ - 3 :] #print (orientation) bpy . context . scene . frame_set ( frame ) bpy . context . view_layer . update () # Update blender context bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Generating point cloud \" , frame_number / ( end - start )) # Display progress on system console for selected_laserline_id in range ( len ( self . laser_list )): # Iterate through all laserline objects #logger.update_progress(\"Generating point cloud \", ((frame_number-start_frame+ (selected_laserline_id/len(self.laser_list)))/(self.end_frame-self.start_frame))) # Display progress on system console intersection = self . laserline_currentframe_interaction ( frame , selected_laserline_id ) if intersection : csv_export_list . append ( intersection ) # Append data to export list #self.check_intersections_frame_range(start,end) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"location\" , frame = frame ) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Export data to csv file def rotating_polygon_iterator ( self ) -> None : \"\"\"Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Note: Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: * All laserlines are processed in batches of the defined `laser_step` * The laserline objects are initialized on demand unlike other senor setups where `preinitialized_frame` is set to True \"\"\" self . end_frame = int ( self . laser_origin_orientation_list [ - 1 ][ 0 ]) # Set End frame laserline_id = 0 #Iterate through laserlines in the given set while laserline_id < len ( self . laser_list ) - self . laser_step : logger . update_progress ( \"laserline\" , laserline_id / ( len ( self . laser_list ) - self . laser_step )) # Display progress on system console # Initialise laserlines if not self . preinitialized_frame : for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] sensor_object = bpy . data . objects [ self . sensor_name ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( laser_raydir ) laser_raydir . parent = laser laser . parent = sensor_object steps = np . arange ( self . start_frame , self . end_frame + self . frame_step , self . frame_step ) #Calcualate frame steps for n in range ( 0 , len ( steps ) - 1 ): start = steps [ n ] - self . start_frame end = min ( steps [ n + 1 ], self . end_frame ) - self . start_frame # Set orientation of laser sensor across the frame range for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) orientation = self . laser_origin_orientation_list [ i ][ - 3 :] bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) self . laser_object_group_frame_range_iterator ( start , end , laserline_id ) #Get intersections across the frame range # Unlink laserlines for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser ) bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser_raydir ) laserline_id += self . laser_step # Delete keyframes for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) def create_export_file ( self ): \"\"\"It calls export function creates a new csv file with the set `data_columns` writes in `w+` mode.\"\"\" self . export ([ self . data_columns ], 'w+' ) def export ( self , data : list , mode : str ): \"\"\"Creates or appends data to a pointcloud.csv file with the given data Args: data: Data to be exported in list form mode: Writing mode eg. `a+` or `w+` \"\"\" try : os . makedirs ( os . path . dirname ( self . out_file_name )) #Create a file if not exists except : None #Append or write data to file try : with open ( self . out_file_name , mode , newline = '' ) as write_obj : csv_writer = csv . writer ( write_obj ) for n in range ( len ( data )): row = data [ n ] csv_writer . writerow ( row ) except : None __init__ ( sensor_data , platform_data ) Initialises all the variables. Calls model accuracy which creates error models for range , incidence and fixed errors . laser_origin_orientation_list is created which provides sensor orientation values (omega, phi and kappa) for each frame. Parameters: Name Type Description Default sensor_data json all parameters of the sensor required platform_data json all platform parameters required Source code in Modules\\laser.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __init__ ( self , sensor_data : json , platform_data : json ) -> None : \"\"\" Initialises all the variables. Calls model accuracy which creates error models for `range`, `incidence` and `fixed errors`. `laser_origin_orientation_list` is created which provides sensor orientation values (omega, phi and kappa) for each frame. Args: sensor_data: all parameters of the sensor platform_data: all platform parameters \"\"\" self . laser_step = 100 #: int: The number of laser lines to process before exporting self . frame_step = 50 #: int: The number of frames to process before exporting self . data_accuracy = 8 #: int: Set last decimal place upto which all data needs to be rounded off self . sensor_data = sensor_data #: json: Get all sensor parameters self . platform_data = platform_data #: json: Get all platform parameters self . sensor_name = self . sensor_data [ \"sensor_name\" ] #: str: Sensor's name self . rotation_type = self . sensor_data [ \"rotation_type\" ] self . scanner_location = self . sensor_data [ \"platform\" ][ \"position\" ] try : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] except : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . sf = sensor_data [ \"parameters\" ][ \"sf\" ] self . start_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"start_fov\" ] self . end_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"end_fov\" ] self . positive_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"start_view_angle\" ] self . negative_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"end_view_angle\" ] self . sensor_range_min = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'min' ] self . sensor_range_max = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'max' ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] self . hfov = self . negative_hfov - self . positive_hfov # Calculate horizontal field of view self . horizontal_deviation_per_pulse = self . sf * self . hfov * self . number_of_channels / self . prf # Calculate horizontal deviation per pulse self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation self . out_file_name = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/Sensor/point_cloud_\" + self . sensor_name + \".csv\" # Set output csv file name #: Initialize lists for error models self . fixed_error_model = [] self . model_range = [] self . range_error_model = [] self . incidence_angle_error_model = [] self . model_accuracy () # Create error models based on selection # Create sensor origin orientation list for each frame for each scanning pattern type self . laser_origin_orientation_list = [] if self . rotation_type == \"rotating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_r () if self . rotation_type == \"osscilating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_o () if self . rotation_type == \"rotating_polygon\" : self . flying_height = self . sensor_data [ 'parameters' ][ 'horizontal_scanning' ][ 'mean_flying_height' ] self . orientation_csv_static_not_rotating () if self . rotation_type == \"flash\" : self . number_of_hor_channels = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] self . orientation_csv_static_not_rotating () self . laser_list = [] #List containing names of laser objects self . data_columns = [ \"//X\" , \"Y\" , \"Z\" , \"Time\" , \"Label\" , \"Instance_id\" , \"Incidence_angle\" , \"Sensor_name\" , \"Pulse_id\" , \"Channel_id\" , \"Rf\" , \"Gf\" , \"Bf\" , \"Af\" , \"Intensity\" ] #List of header names for exported csv file self . csv_export_list = [] #List containing interected points # Get all label values self . dict_data = global_data . bl_scene . label_dict self . dict_values = list ( self . dict_data . values ()) self . dict_keys = list ( self . dict_data . keys ()) global_data . bl_scene . all_data [ 'labels' ] = self . dict_data self . preinitialized_frame = False all_laserlines_frame_range_iterator ( start , end ) Computes intersections for all channels across a given frame range and exports the data to csv file Parameters: Name Type Description Default start int Start frame required end int End Frame required Source code in Modules\\laser.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 def all_laserlines_frame_range_iterator ( self , start : int , end : int ): \"\"\"Computes intersections for all channels across a given frame range and exports the data to csv file Args: start: Start frame end: End Frame \"\"\" steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): csv_export_list = [] #Empty list to store the intersection data start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame #print (start_frame,end_frame,frame_number) # Set blender scene frame frame = int ( self . laser_origin_orientation_list [ frame_number ][ 0 ]) #print (frame) orientation = self . laser_origin_orientation_list [ frame_number ][ - 3 :] #print (orientation) bpy . context . scene . frame_set ( frame ) bpy . context . view_layer . update () # Update blender context bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Generating point cloud \" , frame_number / ( end - start )) # Display progress on system console for selected_laserline_id in range ( len ( self . laser_list )): # Iterate through all laserline objects #logger.update_progress(\"Generating point cloud \", ((frame_number-start_frame+ (selected_laserline_id/len(self.laser_list)))/(self.end_frame-self.start_frame))) # Display progress on system console intersection = self . laserline_currentframe_interaction ( frame , selected_laserline_id ) if intersection : csv_export_list . append ( intersection ) # Append data to export list #self.check_intersections_frame_range(start,end) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"location\" , frame = frame ) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Export data to csv file check_intersection ( graph , origin , direction , distance ) Finds out intersections for a laser vector starting from origin in the direction , upto the given distance . Note It looks for intersection untill a point with zero transparency is found Parameters: Name Type Description Default graph bpy . context Blender scene context required origin mathutils . Vector Location of origin required direction mathutils . Vector Location of direction vector required distance int Maximum range distance required Returns a tuple of the following values Type Description Boolean hit mathutils . Vector location mathutils . Vector normal int index int object list matrix float r float g float b float a float ir Source code in Modules\\laser.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def check_intersection ( self , graph : bpy . context , origin : mathutils . Vector , direction : mathutils . Vector , distance : int ) -> Tuple [ Boolean , mathutils . Vector , mathutils . Vector , int , int , list , float , float , float , float , float ]: \"\"\" Finds out intersections for a laser vector starting from `origin` in the `direction`, upto the given `distance`. Note: It looks for intersection untill a point with zero transparency is found Args: graph: Blender scene context origin: Location of origin direction: Location of direction vector distance: Maximum range distance Returns: Returns a tuple of the following values hit location normal index object matrix r g b a ir \"\"\" r , g , b , a , ir = 0 , 0 , 0 , 0 , 0 location = mathutils . Vector (( 0 , 0 , 0 )) object , matrix , normal , index = None , None , None , None hit = True while ( a == 0 and hit ): # iterate until intersection occurs on an opaque object hit , location , normal , index , object , matrix = bpy . context . scene . ray_cast ( graph , origin = origin , direction = direction , distance = distance ) if hit : try : # Get RGB information from image texture mesh = object . data face = mesh . polygons [ index ] slot = object . material_slots [ face . material_index ] material = slot . material verticesIndices = face . vertices texture_image_name = material . node_tree . nodes [ 'Image Texture' ] . image . name # Transform 3D world location to 2D location on image plane p1 , p2 , p3 = [ object . matrix_world @ object . data . vertices [ verticesIndices [ i ]] . co for i in range ( 3 )] uvMapIndices = face . loop_indices uvMap = object . data . uv_layers [ 'UVMap' ] uv1 = [ uvMap . data [ uvMapIndices [ 0 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 0 ]] . uv [ 1 ], 0 ] uv2 = [ uvMap . data [ uvMapIndices [ 1 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 1 ]] . uv [ 1 ], 0 ] uv3 = [ uvMap . data [ uvMapIndices [ 2 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 2 ]] . uv [ 1 ], 0 ] transformed_location = mathutils . geometry . barycentric_transform ( location , p1 , p2 , p3 , uv1 , uv2 , uv3 ) #Get RGBA values from texture image img = bpy . data . images [ texture_image_name ] width , height = img . size [ 0 : 2 ] index = ((( int (( transformed_location [ 1 ] % 1 ) * height ) * width ) + int (( transformed_location [ 0 ] % 1 ) * width )) - 1 ) * 4 r , g , b , a = img . pixels [ index : index + 4 ] except : # Get RGB information from base colour material_layers = material . node_tree . nodes [ \"Principled BSDF\" ] . inputs r , g , b , a = material_layers [ 'Base Color' ] . default_value ir = ( r + g + b ) / ( 3 * 255 ) #IR value estimation # if a translucent object is found continue the ray ahead after the found point direction = location - origin distance = distance - direction . length origin = location + ( direction . normalized ()) direction = origin - location return ( hit , location , normal , index , object , matrix ,( r , g , b , a , ir )) create_export_file () It calls export function creates a new csv file with the set data_columns writes in w+ mode. Source code in Modules\\laser.py 677 678 679 def create_export_file ( self ): \"\"\"It calls export function creates a new csv file with the set `data_columns` writes in `w+` mode.\"\"\" self . export ([ self . data_columns ], 'w+' ) create_sensor_frame () Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV Source code in Modules\\laser.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def create_sensor_frame ( self ): \"\"\"Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV \"\"\" lidar_sensor_main = bpy . data . objects [ self . sensor_name ] # Get blender object with the given sensor name try : vertical_deviation = ( self . end_vfov - self . start_vfov ) / ( self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] - 1 ) # Deviation between each vertical channel vertical_deviations = np . arange ( self . start_vfov , self . end_vfov + 1 , vertical_deviation ) . tolist () # List of angle of deviation for each vertical channel except : vertical_deviations = [ 0.0 ] # Deviation for a single channel sensor horizontal_deviations = self . get_horizontal_deviation_angles () # Get a list of angle of deviation for each horizontal channel if self . rotation_type == \"rotating_polygon\" : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * len ( horizontal_deviations ) self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation for pulse in range ( len ( horizontal_deviations )): h_dev_angle = horizontal_deviations [ pulse ] # A deviation angle for current horizontal pulse for channel in range ( len ( vertical_deviations )): v_dev_angle = - vertical_deviations [ channel ] # A deviation angle for current vertical channel # Create a laser vector laser = bpy . data . objects . new ( \"laser_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) laser . empty_display_type = 'PLAIN_AXES' laser . empty_display_size = 0.001 laser . location = ( 0 , 0 , 0 ) # Create a laser direction vector l_dir = bpy . data . objects . new ( \"laser_dir_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) l_dir . empty_display_type = 'PLAIN_AXES' l_dir . empty_display_size = 0.001 direction_vector_length = 1 l_dir . location = ( direction_vector_length , 0 , 0 ) # Link the laser vector objects to the current scene if self . preinitialized_frame == True : bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( l_dir ) l_dir . parent = laser laser . parent = lidar_sensor_main # Link the laser vector object to the sensor object laser . rotation_euler = ( 0 , math . radians ( v_dev_angle ), math . radians ( h_dev_angle )) # Rotate the laser vector according the vertical and horizontal deviation self . laser_list . append ( self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel )) # Append the name of laser vector to the laser vector list bpy . context . view_layer . update () # Update blender scene context export ( data , mode ) Creates or appends data to a pointcloud.csv file with the given data Parameters: Name Type Description Default data list Data to be exported in list form required mode str Writing mode eg. a+ or w+ required Source code in Modules\\laser.py 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 def export ( self , data : list , mode : str ): \"\"\"Creates or appends data to a pointcloud.csv file with the given data Args: data: Data to be exported in list form mode: Writing mode eg. `a+` or `w+` \"\"\" try : os . makedirs ( os . path . dirname ( self . out_file_name )) #Create a file if not exists except : None #Append or write data to file try : with open ( self . out_file_name , mode , newline = '' ) as write_obj : csv_writer = csv . writer ( write_obj ) for n in range ( len ( data )): row = data [ n ] csv_writer . writerow ( row ) except : None get_fixed_error () Returns a random error value from the fixed error model Returns: Type Description list [error in x, error in y, error in z] Source code in Modules\\laser.py 210 211 212 213 214 215 216 217 218 219 220 def get_fixed_error ( self ) -> list : \"\"\"Returns a random error value from the fixed error model Returns: [error in x, error in y, error in z] \"\"\" error_x = random . choices ( self . fixed_error_model [ 0 ], k = 1 )[ 0 ] error_y = random . choices ( self . fixed_error_model [ 1 ], k = 1 )[ 0 ] error_z = random . choices ( self . fixed_error_model [ 2 ], k = 1 )[ 0 ] return [ error_x , error_y , error_z ] get_horizontal_deviation_angles () Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Type Description np . ndarray Numpy list of angles of deviation for each laser line Source code in Modules\\laser.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def get_horizontal_deviation_angles ( self ) -> np . ndarray : \"\"\" Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Numpy list of angles of deviation for each laser line \"\"\" # For Rotatind and Osscilating if self . rotation_type == \"rotating\" or self . rotation_type == \"osscilating\" : angle_list = np . array ([ 0 ]) # For Flash if self . rotation_type == \"flash\" : angle_dev = ( self . negative_hfov - self . positive_hfov ) / ( self . number_of_hor_channels - 1 ) angle_list = np . arange ( self . positive_hfov , self . negative_hfov + 1 , angle_dev ) # For Rotating polygon style if self . rotation_type == \"rotating_polygon\" : angle_sublist = [ 0 ] #print (self.flying_height,math.tan(math.radians(self.hfov)),self.sf,self.prf) ground_spacing = self . flying_height * math . tan ( math . radians ( self . hfov )) * self . sf / self . prf # Calculate ground spacing if ( np . sign ( self . negative_hfov ) != np . sign ( self . positive_hfov )): for angle in [ math . radians ( self . negative_hfov ), math . radians ( self . positive_hfov )]: swath_width = self . flying_height * math . tan ( abs ( angle )) # Calculate Swath width n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( n * ground_spacing ) / self . flying_height )) ) * ( angle / abs ( angle )) #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) else : sign = ( self . negative_hfov / self . positive_hfov ) / abs (( self . negative_hfov / self . positive_hfov )) signed_hfov = abs ( math . radians ( self . negative_hfov ) - math . radians ( self . positive_hfov )) * ( sign ) swath_width = self . flying_height * math . tan ( abs ( signed_hfov )) initial_angle = min ( abs ( math . radians ( self . negative_hfov )), abs ( math . radians ( self . positive_hfov ))) initial_width = self . flying_height * math . tan ( abs ( initial_angle )) n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( initial_width + ( n * ground_spacing )) / self . flying_height )) ) * sign #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) angle_list = np . unique ( np . array ( angle_sublist ) . flatten ()) # Rearrange array and remove duplicate angle values return angle_list get_incidence_error ( angle ) Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: Type Description np . ndarray List of errors for x, y, z - list(error in x, error in y, error in z) Source code in Modules\\laser.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_incidence_error ( self , angle : float ) -> np . ndarray : \"\"\"Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: List of errors for x, y, z - list(error in x, error in y, error in z) \"\"\" try : accuracy_at_angle = self . incidence_angle_error_model [ np . where ( self . model_incidence_angle == int ( angle ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_angle = 0 indicence_angle_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_angle ), size = 1 )[ 0 ] # Computed error list return indicence_angle_error get_label_id ( obj_name ) Returns label id based on the intersected object's name. It looks for object_name in dict_values and returns its id from dict_keys. If object name is not found in the label dictionary, id is set to 999 Parameters: Name Type Description Default obj_name string Object's Name required Returns: Type Description int Label id Source code in Modules\\laser.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def get_label_id ( self , obj_name : string ) -> int : \"\"\"Returns label id based on the intersected object's name. * It looks for object_name in dict_values and returns its id from dict_keys. * If object name is not found in the label dictionary, id is set to 999 Args: obj_name: Object's Name Returns: Label id \"\"\" try : label_id = self . dict_values . index ( obj_name . lower ()) label = self . dict_keys [ label_id ] except : label = 999 return ( label ) get_range_error ( range ) Returns a list of random values based on input range Generates random error from a normal distribution with a standard deviation for the given range from range_error_model Parameters: Name Type Description Default range float Range at which the point exists required Returns: Type Description np . ndarray Error in range Source code in Modules\\laser.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def get_range_error ( self , range : float ) -> np . ndarray : \"\"\"Returns a list of random values based on input `range` Generates random error from a normal distribution with a standard deviation for the given `range` from `range_error_model` Args: range:Range at which the point exists Returns: Error in range \"\"\" try : accuracy_at_range = self . range_error_model [ np . where ( self . model_range == int ( range ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_range = 0 range_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_range ), size = 1 )[ 0 ] # Computed range error return range_error laser_object_group_frame_range_iterator ( start , end , laserline_id ) Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Parameters: Name Type Description Default start int Start frame required end int End Frame required laserline_id int Id of the selected laserline required Source code in Modules\\laser.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def laser_object_group_frame_range_iterator ( self , start : int , end : int , laserline_id : int ) -> None : \"\"\"Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Args: start: Start frame end: End Frame laserline_id: Id of the selected laserline \"\"\" bpy . context . view_layer . update () # Update blender context csv_export_list = [] #Empty list to store the intersection data steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame # Set frame frame = int ( self . laser_origin_orientation_list [ frame_number - start ][ 0 ]) bpy . context . scene . frame_set ( frame ) for selected_laserline_id in range ( laserline_id , laserline_id + self . laser_step ): #iterate through laser line group if self . laserline_currentframe_interaction ( frame , selected_laserline_id ): csv_export_list . append ( self . laserline_currentframe_interaction ( frame , selected_laserline_id )) # Append data to export list if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Append data to csv file laserline_currentframe_interaction ( frame , selected_laserline_id ) Computes intersections for a selected laserline on the given frame Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] Source code in Modules\\laser.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def laserline_currentframe_interaction ( self , frame : int , selected_laserline_id : int ) -> list : \"\"\"Computes intersections for a selected laserline on the given frame Args: frame (int), selected_laserline_id (int) Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] \"\"\" bpy . context . view_layer . update () # Update blender context # Get laser origin and direction locations ray_origin = bpy . context . scene . objects [ \"laser_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () ray_direction_pt = bpy . context . scene . objects [ \"laser_dir_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () graph = bpy . context . evaluated_depsgraph_get () # Get scene context hit , location , normal , index , object , matrix , colour = self . check_intersection ( graph , ray_origin , ray_direction_pt - ray_origin , self . sensor_range_max ) # Get intersction point with RGBIR # Calculate Range incident_ray = location - ray_origin range = incident_ray . length if hit and range > self . sensor_range_min : # Check if intersection occured and range is greater than minimum range # Calculate Incidence Angle normal *= - 1 incidence_angle = incident_ray . rotation_difference ( normal ) . angle # Get error values range_error = self . get_range_error ( range ) incidence_error = self . get_incidence_error ( incidence_angle ) fixed_error_list = self . get_fixed_error () # Compute erronous incidence angle # Compute erronous range erronous_range = range + range_error # Compute new location unit_incident_ray = incident_ray / range updated_incident_ray = unit_incident_ray * erronous_range + ray_origin location = updated_incident_ray # Compute final position x = round ( location [ 0 ] + fixed_error_list [ 0 ], self . data_accuracy ) y = round ( location [ 1 ] + fixed_error_list [ 1 ], self . data_accuracy ) z = round ( location [ 2 ] + fixed_error_list [ 2 ], self . data_accuracy ) t = frame * self . time_per_horizontal_dev pulse_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 2 ]) channel_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 1 ]) r , g , b , a , ir = colour intensity = round ( ir * math . cos ( incidence_angle ) * 255 / ( range ** 2 ), self . data_accuracy ) label = str ( self . get_label_id ( object . name . split ( \".\" )[ 0 ])) try : instance_id = str ( object . name . split ( \".\" )[ 1 ]) except : instance_id = \"000\" #print (x,y,z) return ([ x , y , z , t , label , instance_id , incidence_angle , self . sensor_name , frame , channel_id , r , g , b , a , intensity ]) lidar_sensor_main () Main class to handle creation of sensor frame and to check intersections Source code in Modules\\laser.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def lidar_sensor_main ( self ) -> None : \"\"\"Main class to handle creation of sensor frame and to check intersections\"\"\" bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects global_data . bl_scene . all_data [ \"time\" ] = 0 export_json ( True ) # Export json file starttime = time . time () #Start time self . create_export_file () # Create output csv file with headers # Based on sensor type - create a sensor frame, then iterate over the previously create orientation list if self . rotation_type == \"rotating_polygon\" or self . rotation_type == \"flash\" : self . create_sensor_frame () self . rotating_polygon_iterator () if self . rotation_type == \"osscilating\" or self . rotation_type == \"rotating\" : self . preinitialized_frame = True self . create_sensor_frame () self . all_laserlines_frame_range_iterator ( self . start_frame , self . end_frame ) endtime = time . time () #End time global_data . bl_scene . all_data [ \"time\" ] = endtime - starttime export_json ( True ) # Export json file bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects for next run model_accuracy () Generates a accuracy model based on the error type Source code in Modules\\laser.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def model_accuracy ( self ) -> None : \"\"\"Generates a accuracy model based on the error type \"\"\" if ( \"fixed\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Genrates a list of random errors based on the standard dev values from user try : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'x' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'y' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] except : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] self . fixed_error_model = [ np . random . normal ( loc = 0 , scale = float ( fixed_error_x ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_y ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_z ), size = 10000 )] if ( \"range\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree range vs accuracy curve self . model_range = np . linspace ( self . sensor_range_min , self . sensor_range_max , self . sensor_range_max , dtype = int ) range_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a1' ] # User input for coefficient of x^2 range_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a2' ] # User input for coefficient of x range_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a3' ] # User input for error at minimum range self . range_error_model = ( range_a1 * ( self . model_range ** 2 )) + ( range_a2 * self . model_range ) + range_a3 if ( \"incidence\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree incidence angle vs accuracy curve min_incidence_angle = 0 max_incidence_angle = 1.58 step = 0.01 self . model_incidence_angle = np . arange ( min_incidence_angle , max_incidence_angle , step ) incidence_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a1' ] # User input for coefficient of x^2 incidence_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a2' ] # User input for coefficient of x incidence_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a3' ] # User input for error at minimum range self . incidence_angle_error_model = ( incidence_a1 * ( self . model_incidence_angle ** 2 )) + ( incidence_a2 * self . model_incidence_angle ) + incidence_a3 orientation_csv_static_not_rotating () Creates a positition orientation list for a stationary non rotating type of scanner Source code in Modules\\laser.py 340 341 342 343 344 345 346 def orientation_csv_static_not_rotating ( self ): \"\"\"Creates a positition orientation list for a stationary non rotating type of scanner \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): self . laser_origin_orientation_list . append ([ i , 0 , 0 , 0 ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) orientation_csv_static_o () Generates a list for orientation values for a Osscilating type sensor Source code in Modules\\laser.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def orientation_csv_static_o ( self ): \"\"\"Generates a list for orientation values for a Osscilating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = i * self . deviation_per_frame if int ( dev_angle / self . hfov ) % 2 == 0 : dev_angle = dev_angle % self . hfov else : dev_angle = self . hfov - ( dev_angle % self . hfov ) dev_angle += self . positive_hfov self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) orientation_csv_static_r () Generates a list for orientation values for a rotating type sensor Source code in Modules\\laser.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def orientation_csv_static_r ( self ): \"\"\"Generates a list for orientation values for a rotating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = ( i * self . deviation_per_frame ) + self . positive_hfov if ( dev_angle % 360 < self . negative_hfov ): dev_angle = dev_angle % 360 self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) else : self . laser_origin_orientation_list . append ([ i , \"skip\" , \"skip\" , \"skip\" ]) # Skip laser line generation while out of FOV self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) rotating_polygon_iterator () Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: All laserlines are processed in batches of the defined laser_step The laserline objects are initialized on demand unlike other senor setups where preinitialized_frame is set to True Source code in Modules\\laser.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 def rotating_polygon_iterator ( self ) -> None : \"\"\"Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Note: Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: * All laserlines are processed in batches of the defined `laser_step` * The laserline objects are initialized on demand unlike other senor setups where `preinitialized_frame` is set to True \"\"\" self . end_frame = int ( self . laser_origin_orientation_list [ - 1 ][ 0 ]) # Set End frame laserline_id = 0 #Iterate through laserlines in the given set while laserline_id < len ( self . laser_list ) - self . laser_step : logger . update_progress ( \"laserline\" , laserline_id / ( len ( self . laser_list ) - self . laser_step )) # Display progress on system console # Initialise laserlines if not self . preinitialized_frame : for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] sensor_object = bpy . data . objects [ self . sensor_name ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( laser_raydir ) laser_raydir . parent = laser laser . parent = sensor_object steps = np . arange ( self . start_frame , self . end_frame + self . frame_step , self . frame_step ) #Calcualate frame steps for n in range ( 0 , len ( steps ) - 1 ): start = steps [ n ] - self . start_frame end = min ( steps [ n + 1 ], self . end_frame ) - self . start_frame # Set orientation of laser sensor across the frame range for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) orientation = self . laser_origin_orientation_list [ i ][ - 3 :] bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) self . laser_object_group_frame_range_iterator ( start , end , laserline_id ) #Get intersections across the frame range # Unlink laserlines for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser ) bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser_raydir ) laserline_id += self . laser_step # Delete keyframes for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) visulize_sensor_frame () Visulises the sensor frame Source code in Modules\\laser.py 168 169 170 171 172 def visulize_sensor_frame ( self ) -> None : \"\"\"Visulises the sensor frame \"\"\" self . preinitialized_frame = True self . create_sensor_frame ()","title":"Laser Module"},{"location":"modules/laser/#laser-module","text":"","title":"Laser Module"},{"location":"modules/laser/#Modules.laser.laser_sensor","text":"Creates a laser sensor object with the provided sensor data Attributes: Name Type Description platform_data dict platform_data sensor_data dict sensor_data start_frame int First frame number to start rendering from end_frame int Last frame number to end rendering at prf int Pulse Repetition Frequency sf int Scanning Frequency rotation_type str Type of rotation csv_export_list list List containing all the intersection points data_accuracy int Set last decimal place upto which all data needs to be rounded off data_columns list List of header names of the exported csv file time_per_horizontal_dev float Time interval in seconds between each deviation deviation_per_frame float Angle of deviation between each frame (in degree) dict_data dict A dictionary containing labels and their respective id's dict_keys list List of label id dict_values list List of label names start_vfov float Start of vertical frame of view end_vfov float End of vertical field of view positive_hfov float Start of horizontal feild of view negative_hfov float End of horizontal feild of view flying_height int Mean flying height for rotating polygon type sensor frame_step int The number of frames to process before exporting hfov float Horizontal Field of view horizontal_deviation_per_pulse float Angle of deviation between each horizontal channel (in degree) laser_list list List containg names of all laserline objects laser_origin_orientation_list list List containing orientation values at each frame laser_step int The number of laser lines to process before exporting number_of_channels int Number of vertical channels number_of_hor_channels int Number of horizontal channels out_file_name str File path of the output file name preinitialized_frame bool preinitialized_frame pulses_per_frame int Number of pulses emitted at each frame rotation_type str Rotation type of the lidar sensor scanner_location list Scanner's location in the platform's local coordinate system [x,y,z] sensor_name str Sensor's name sensor_range_max int Maximum range of sensor sensor_range_min int Minimum range of sensor fixed_error_model list List containing lists of randomly generated error values for x, y and z model_range list List of all range values between sensor_range_max and sensor_range_min range_error_model array range_error_model incidence_angle_error_model array incidence_angle_error_model Source code in Modules\\laser.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 class laser_sensor : \"\"\"Creates a laser sensor object with the provided sensor data Attributes: platform_data (dict): platform_data sensor_data (dict): sensor_data start_frame (int): First frame number to start rendering from end_frame (int): Last frame number to end rendering at prf (int): Pulse Repetition Frequency sf (int): Scanning Frequency rotation_type (str): Type of rotation csv_export_list (list): List containing all the intersection points data_accuracy (int): Set last decimal place upto which all data needs to be rounded off data_columns (list): List of header names of the exported csv file time_per_horizontal_dev (float): Time interval in seconds between each deviation deviation_per_frame (float): Angle of deviation between each frame (in degree) dict_data (dict): A dictionary containing labels and their respective id's dict_keys (list): List of label id dict_values (list): List of label names start_vfov (float): Start of vertical frame of view end_vfov (float): End of vertical field of view positive_hfov (float): Start of horizontal feild of view negative_hfov (float): End of horizontal feild of view flying_height (int): Mean flying height for rotating polygon type sensor frame_step (int): The number of frames to process before exporting hfov (float): Horizontal Field of view horizontal_deviation_per_pulse (float): Angle of deviation between each horizontal channel (in degree) laser_list (list): List containg names of all laserline objects laser_origin_orientation_list (list): List containing orientation values at each frame laser_step (int): The number of laser lines to process before exporting number_of_channels (int): Number of vertical channels number_of_hor_channels (int): Number of horizontal channels out_file_name (str): File path of the output file name preinitialized_frame (bool): preinitialized_frame pulses_per_frame (int): Number of pulses emitted at each frame rotation_type (str): Rotation type of the lidar sensor scanner_location (list): Scanner's location in the platform's local coordinate system [x,y,z] sensor_name (str): Sensor's name sensor_range_max (int): Maximum range of sensor sensor_range_min (int): Minimum range of sensor fixed_error_model (list): List containing lists of randomly generated error values for x, y and z model_range (list): List of all range values between sensor_range_max and sensor_range_min range_error_model (array): range_error_model incidence_angle_error_model (array): incidence_angle_error_model \"\"\" def __init__ ( self , sensor_data : json , platform_data : json ) -> None : \"\"\" Initialises all the variables. Calls model accuracy which creates error models for `range`, `incidence` and `fixed errors`. `laser_origin_orientation_list` is created which provides sensor orientation values (omega, phi and kappa) for each frame. Args: sensor_data: all parameters of the sensor platform_data: all platform parameters \"\"\" self . laser_step = 100 #: int: The number of laser lines to process before exporting self . frame_step = 50 #: int: The number of frames to process before exporting self . data_accuracy = 8 #: int: Set last decimal place upto which all data needs to be rounded off self . sensor_data = sensor_data #: json: Get all sensor parameters self . platform_data = platform_data #: json: Get all platform parameters self . sensor_name = self . sensor_data [ \"sensor_name\" ] #: str: Sensor's name self . rotation_type = self . sensor_data [ \"rotation_type\" ] self . scanner_location = self . sensor_data [ \"platform\" ][ \"position\" ] try : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] except : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . sf = sensor_data [ \"parameters\" ][ \"sf\" ] self . start_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"start_fov\" ] self . end_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"end_fov\" ] self . positive_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"start_view_angle\" ] self . negative_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"end_view_angle\" ] self . sensor_range_min = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'min' ] self . sensor_range_max = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'max' ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] self . hfov = self . negative_hfov - self . positive_hfov # Calculate horizontal field of view self . horizontal_deviation_per_pulse = self . sf * self . hfov * self . number_of_channels / self . prf # Calculate horizontal deviation per pulse self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation self . out_file_name = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/Sensor/point_cloud_\" + self . sensor_name + \".csv\" # Set output csv file name #: Initialize lists for error models self . fixed_error_model = [] self . model_range = [] self . range_error_model = [] self . incidence_angle_error_model = [] self . model_accuracy () # Create error models based on selection # Create sensor origin orientation list for each frame for each scanning pattern type self . laser_origin_orientation_list = [] if self . rotation_type == \"rotating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_r () if self . rotation_type == \"osscilating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_o () if self . rotation_type == \"rotating_polygon\" : self . flying_height = self . sensor_data [ 'parameters' ][ 'horizontal_scanning' ][ 'mean_flying_height' ] self . orientation_csv_static_not_rotating () if self . rotation_type == \"flash\" : self . number_of_hor_channels = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] self . orientation_csv_static_not_rotating () self . laser_list = [] #List containing names of laser objects self . data_columns = [ \"//X\" , \"Y\" , \"Z\" , \"Time\" , \"Label\" , \"Instance_id\" , \"Incidence_angle\" , \"Sensor_name\" , \"Pulse_id\" , \"Channel_id\" , \"Rf\" , \"Gf\" , \"Bf\" , \"Af\" , \"Intensity\" ] #List of header names for exported csv file self . csv_export_list = [] #List containing interected points # Get all label values self . dict_data = global_data . bl_scene . label_dict self . dict_values = list ( self . dict_data . values ()) self . dict_keys = list ( self . dict_data . keys ()) global_data . bl_scene . all_data [ 'labels' ] = self . dict_data self . preinitialized_frame = False def lidar_sensor_main ( self ) -> None : \"\"\"Main class to handle creation of sensor frame and to check intersections\"\"\" bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects global_data . bl_scene . all_data [ \"time\" ] = 0 export_json ( True ) # Export json file starttime = time . time () #Start time self . create_export_file () # Create output csv file with headers # Based on sensor type - create a sensor frame, then iterate over the previously create orientation list if self . rotation_type == \"rotating_polygon\" or self . rotation_type == \"flash\" : self . create_sensor_frame () self . rotating_polygon_iterator () if self . rotation_type == \"osscilating\" or self . rotation_type == \"rotating\" : self . preinitialized_frame = True self . create_sensor_frame () self . all_laserlines_frame_range_iterator ( self . start_frame , self . end_frame ) endtime = time . time () #End time global_data . bl_scene . all_data [ \"time\" ] = endtime - starttime export_json ( True ) # Export json file bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects for next run def visulize_sensor_frame ( self ) -> None : \"\"\"Visulises the sensor frame \"\"\" self . preinitialized_frame = True self . create_sensor_frame () def model_accuracy ( self ) -> None : \"\"\"Generates a accuracy model based on the error type \"\"\" if ( \"fixed\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Genrates a list of random errors based on the standard dev values from user try : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'x' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'y' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] except : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] self . fixed_error_model = [ np . random . normal ( loc = 0 , scale = float ( fixed_error_x ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_y ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_z ), size = 10000 )] if ( \"range\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree range vs accuracy curve self . model_range = np . linspace ( self . sensor_range_min , self . sensor_range_max , self . sensor_range_max , dtype = int ) range_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a1' ] # User input for coefficient of x^2 range_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a2' ] # User input for coefficient of x range_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a3' ] # User input for error at minimum range self . range_error_model = ( range_a1 * ( self . model_range ** 2 )) + ( range_a2 * self . model_range ) + range_a3 if ( \"incidence\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree incidence angle vs accuracy curve min_incidence_angle = 0 max_incidence_angle = 1.58 step = 0.01 self . model_incidence_angle = np . arange ( min_incidence_angle , max_incidence_angle , step ) incidence_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a1' ] # User input for coefficient of x^2 incidence_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a2' ] # User input for coefficient of x incidence_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a3' ] # User input for error at minimum range self . incidence_angle_error_model = ( incidence_a1 * ( self . model_incidence_angle ** 2 )) + ( incidence_a2 * self . model_incidence_angle ) + incidence_a3 def get_fixed_error ( self ) -> list : \"\"\"Returns a random error value from the fixed error model Returns: [error in x, error in y, error in z] \"\"\" error_x = random . choices ( self . fixed_error_model [ 0 ], k = 1 )[ 0 ] error_y = random . choices ( self . fixed_error_model [ 1 ], k = 1 )[ 0 ] error_z = random . choices ( self . fixed_error_model [ 2 ], k = 1 )[ 0 ] return [ error_x , error_y , error_z ] def get_range_error ( self , range : float ) -> np . ndarray : \"\"\"Returns a list of random values based on input `range` Generates random error from a normal distribution with a standard deviation for the given `range` from `range_error_model` Args: range:Range at which the point exists Returns: Error in range \"\"\" try : accuracy_at_range = self . range_error_model [ np . where ( self . model_range == int ( range ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_range = 0 range_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_range ), size = 1 )[ 0 ] # Computed range error return range_error def get_incidence_error ( self , angle : float ) -> np . ndarray : \"\"\"Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: List of errors for x, y, z - list(error in x, error in y, error in z) \"\"\" try : accuracy_at_angle = self . incidence_angle_error_model [ np . where ( self . model_incidence_angle == int ( angle ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_angle = 0 indicence_angle_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_angle ), size = 1 )[ 0 ] # Computed error list return indicence_angle_error def get_horizontal_deviation_angles ( self ) -> np . ndarray : \"\"\" Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Numpy list of angles of deviation for each laser line \"\"\" # For Rotatind and Osscilating if self . rotation_type == \"rotating\" or self . rotation_type == \"osscilating\" : angle_list = np . array ([ 0 ]) # For Flash if self . rotation_type == \"flash\" : angle_dev = ( self . negative_hfov - self . positive_hfov ) / ( self . number_of_hor_channels - 1 ) angle_list = np . arange ( self . positive_hfov , self . negative_hfov + 1 , angle_dev ) # For Rotating polygon style if self . rotation_type == \"rotating_polygon\" : angle_sublist = [ 0 ] #print (self.flying_height,math.tan(math.radians(self.hfov)),self.sf,self.prf) ground_spacing = self . flying_height * math . tan ( math . radians ( self . hfov )) * self . sf / self . prf # Calculate ground spacing if ( np . sign ( self . negative_hfov ) != np . sign ( self . positive_hfov )): for angle in [ math . radians ( self . negative_hfov ), math . radians ( self . positive_hfov )]: swath_width = self . flying_height * math . tan ( abs ( angle )) # Calculate Swath width n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( n * ground_spacing ) / self . flying_height )) ) * ( angle / abs ( angle )) #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) else : sign = ( self . negative_hfov / self . positive_hfov ) / abs (( self . negative_hfov / self . positive_hfov )) signed_hfov = abs ( math . radians ( self . negative_hfov ) - math . radians ( self . positive_hfov )) * ( sign ) swath_width = self . flying_height * math . tan ( abs ( signed_hfov )) initial_angle = min ( abs ( math . radians ( self . negative_hfov )), abs ( math . radians ( self . positive_hfov ))) initial_width = self . flying_height * math . tan ( abs ( initial_angle )) n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( initial_width + ( n * ground_spacing )) / self . flying_height )) ) * sign #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) angle_list = np . unique ( np . array ( angle_sublist ) . flatten ()) # Rearrange array and remove duplicate angle values return angle_list def orientation_csv_static_r ( self ): \"\"\"Generates a list for orientation values for a rotating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = ( i * self . deviation_per_frame ) + self . positive_hfov if ( dev_angle % 360 < self . negative_hfov ): dev_angle = dev_angle % 360 self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) else : self . laser_origin_orientation_list . append ([ i , \"skip\" , \"skip\" , \"skip\" ]) # Skip laser line generation while out of FOV self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def orientation_csv_static_o ( self ): \"\"\"Generates a list for orientation values for a Osscilating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = i * self . deviation_per_frame if int ( dev_angle / self . hfov ) % 2 == 0 : dev_angle = dev_angle % self . hfov else : dev_angle = self . hfov - ( dev_angle % self . hfov ) dev_angle += self . positive_hfov self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def orientation_csv_static_not_rotating ( self ): \"\"\"Creates a positition orientation list for a stationary non rotating type of scanner \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): self . laser_origin_orientation_list . append ([ i , 0 , 0 , 0 ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list ) def create_sensor_frame ( self ): \"\"\"Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV \"\"\" lidar_sensor_main = bpy . data . objects [ self . sensor_name ] # Get blender object with the given sensor name try : vertical_deviation = ( self . end_vfov - self . start_vfov ) / ( self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] - 1 ) # Deviation between each vertical channel vertical_deviations = np . arange ( self . start_vfov , self . end_vfov + 1 , vertical_deviation ) . tolist () # List of angle of deviation for each vertical channel except : vertical_deviations = [ 0.0 ] # Deviation for a single channel sensor horizontal_deviations = self . get_horizontal_deviation_angles () # Get a list of angle of deviation for each horizontal channel if self . rotation_type == \"rotating_polygon\" : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * len ( horizontal_deviations ) self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation for pulse in range ( len ( horizontal_deviations )): h_dev_angle = horizontal_deviations [ pulse ] # A deviation angle for current horizontal pulse for channel in range ( len ( vertical_deviations )): v_dev_angle = - vertical_deviations [ channel ] # A deviation angle for current vertical channel # Create a laser vector laser = bpy . data . objects . new ( \"laser_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) laser . empty_display_type = 'PLAIN_AXES' laser . empty_display_size = 0.001 laser . location = ( 0 , 0 , 0 ) # Create a laser direction vector l_dir = bpy . data . objects . new ( \"laser_dir_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) l_dir . empty_display_type = 'PLAIN_AXES' l_dir . empty_display_size = 0.001 direction_vector_length = 1 l_dir . location = ( direction_vector_length , 0 , 0 ) # Link the laser vector objects to the current scene if self . preinitialized_frame == True : bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( l_dir ) l_dir . parent = laser laser . parent = lidar_sensor_main # Link the laser vector object to the sensor object laser . rotation_euler = ( 0 , math . radians ( v_dev_angle ), math . radians ( h_dev_angle )) # Rotate the laser vector according the vertical and horizontal deviation self . laser_list . append ( self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel )) # Append the name of laser vector to the laser vector list bpy . context . view_layer . update () # Update blender scene context def get_label_id ( self , obj_name : string ) -> int : \"\"\"Returns label id based on the intersected object's name. * It looks for object_name in dict_values and returns its id from dict_keys. * If object name is not found in the label dictionary, id is set to 999 Args: obj_name: Object's Name Returns: Label id \"\"\" try : label_id = self . dict_values . index ( obj_name . lower ()) label = self . dict_keys [ label_id ] except : label = 999 return ( label ) def laserline_currentframe_interaction ( self , frame : int , selected_laserline_id : int ) -> list : \"\"\"Computes intersections for a selected laserline on the given frame Args: frame (int), selected_laserline_id (int) Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] \"\"\" bpy . context . view_layer . update () # Update blender context # Get laser origin and direction locations ray_origin = bpy . context . scene . objects [ \"laser_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () ray_direction_pt = bpy . context . scene . objects [ \"laser_dir_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () graph = bpy . context . evaluated_depsgraph_get () # Get scene context hit , location , normal , index , object , matrix , colour = self . check_intersection ( graph , ray_origin , ray_direction_pt - ray_origin , self . sensor_range_max ) # Get intersction point with RGBIR # Calculate Range incident_ray = location - ray_origin range = incident_ray . length if hit and range > self . sensor_range_min : # Check if intersection occured and range is greater than minimum range # Calculate Incidence Angle normal *= - 1 incidence_angle = incident_ray . rotation_difference ( normal ) . angle # Get error values range_error = self . get_range_error ( range ) incidence_error = self . get_incidence_error ( incidence_angle ) fixed_error_list = self . get_fixed_error () # Compute erronous incidence angle # Compute erronous range erronous_range = range + range_error # Compute new location unit_incident_ray = incident_ray / range updated_incident_ray = unit_incident_ray * erronous_range + ray_origin location = updated_incident_ray # Compute final position x = round ( location [ 0 ] + fixed_error_list [ 0 ], self . data_accuracy ) y = round ( location [ 1 ] + fixed_error_list [ 1 ], self . data_accuracy ) z = round ( location [ 2 ] + fixed_error_list [ 2 ], self . data_accuracy ) t = frame * self . time_per_horizontal_dev pulse_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 2 ]) channel_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 1 ]) r , g , b , a , ir = colour intensity = round ( ir * math . cos ( incidence_angle ) * 255 / ( range ** 2 ), self . data_accuracy ) label = str ( self . get_label_id ( object . name . split ( \".\" )[ 0 ])) try : instance_id = str ( object . name . split ( \".\" )[ 1 ]) except : instance_id = \"000\" #print (x,y,z) return ([ x , y , z , t , label , instance_id , incidence_angle , self . sensor_name , frame , channel_id , r , g , b , a , intensity ]) def check_intersection ( self , graph : bpy . context , origin : mathutils . Vector , direction : mathutils . Vector , distance : int ) -> Tuple [ Boolean , mathutils . Vector , mathutils . Vector , int , int , list , float , float , float , float , float ]: \"\"\" Finds out intersections for a laser vector starting from `origin` in the `direction`, upto the given `distance`. Note: It looks for intersection untill a point with zero transparency is found Args: graph: Blender scene context origin: Location of origin direction: Location of direction vector distance: Maximum range distance Returns: Returns a tuple of the following values hit location normal index object matrix r g b a ir \"\"\" r , g , b , a , ir = 0 , 0 , 0 , 0 , 0 location = mathutils . Vector (( 0 , 0 , 0 )) object , matrix , normal , index = None , None , None , None hit = True while ( a == 0 and hit ): # iterate until intersection occurs on an opaque object hit , location , normal , index , object , matrix = bpy . context . scene . ray_cast ( graph , origin = origin , direction = direction , distance = distance ) if hit : try : # Get RGB information from image texture mesh = object . data face = mesh . polygons [ index ] slot = object . material_slots [ face . material_index ] material = slot . material verticesIndices = face . vertices texture_image_name = material . node_tree . nodes [ 'Image Texture' ] . image . name # Transform 3D world location to 2D location on image plane p1 , p2 , p3 = [ object . matrix_world @ object . data . vertices [ verticesIndices [ i ]] . co for i in range ( 3 )] uvMapIndices = face . loop_indices uvMap = object . data . uv_layers [ 'UVMap' ] uv1 = [ uvMap . data [ uvMapIndices [ 0 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 0 ]] . uv [ 1 ], 0 ] uv2 = [ uvMap . data [ uvMapIndices [ 1 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 1 ]] . uv [ 1 ], 0 ] uv3 = [ uvMap . data [ uvMapIndices [ 2 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 2 ]] . uv [ 1 ], 0 ] transformed_location = mathutils . geometry . barycentric_transform ( location , p1 , p2 , p3 , uv1 , uv2 , uv3 ) #Get RGBA values from texture image img = bpy . data . images [ texture_image_name ] width , height = img . size [ 0 : 2 ] index = ((( int (( transformed_location [ 1 ] % 1 ) * height ) * width ) + int (( transformed_location [ 0 ] % 1 ) * width )) - 1 ) * 4 r , g , b , a = img . pixels [ index : index + 4 ] except : # Get RGB information from base colour material_layers = material . node_tree . nodes [ \"Principled BSDF\" ] . inputs r , g , b , a = material_layers [ 'Base Color' ] . default_value ir = ( r + g + b ) / ( 3 * 255 ) #IR value estimation # if a translucent object is found continue the ray ahead after the found point direction = location - origin distance = distance - direction . length origin = location + ( direction . normalized ()) direction = origin - location return ( hit , location , normal , index , object , matrix ,( r , g , b , a , ir )) def laser_object_group_frame_range_iterator ( self , start : int , end : int , laserline_id : int ) -> None : \"\"\"Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Args: start: Start frame end: End Frame laserline_id: Id of the selected laserline \"\"\" bpy . context . view_layer . update () # Update blender context csv_export_list = [] #Empty list to store the intersection data steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame # Set frame frame = int ( self . laser_origin_orientation_list [ frame_number - start ][ 0 ]) bpy . context . scene . frame_set ( frame ) for selected_laserline_id in range ( laserline_id , laserline_id + self . laser_step ): #iterate through laser line group if self . laserline_currentframe_interaction ( frame , selected_laserline_id ): csv_export_list . append ( self . laserline_currentframe_interaction ( frame , selected_laserline_id )) # Append data to export list if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Append data to csv file def all_laserlines_frame_range_iterator ( self , start : int , end : int ): \"\"\"Computes intersections for all channels across a given frame range and exports the data to csv file Args: start: Start frame end: End Frame \"\"\" steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): csv_export_list = [] #Empty list to store the intersection data start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame #print (start_frame,end_frame,frame_number) # Set blender scene frame frame = int ( self . laser_origin_orientation_list [ frame_number ][ 0 ]) #print (frame) orientation = self . laser_origin_orientation_list [ frame_number ][ - 3 :] #print (orientation) bpy . context . scene . frame_set ( frame ) bpy . context . view_layer . update () # Update blender context bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Generating point cloud \" , frame_number / ( end - start )) # Display progress on system console for selected_laserline_id in range ( len ( self . laser_list )): # Iterate through all laserline objects #logger.update_progress(\"Generating point cloud \", ((frame_number-start_frame+ (selected_laserline_id/len(self.laser_list)))/(self.end_frame-self.start_frame))) # Display progress on system console intersection = self . laserline_currentframe_interaction ( frame , selected_laserline_id ) if intersection : csv_export_list . append ( intersection ) # Append data to export list #self.check_intersections_frame_range(start,end) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"location\" , frame = frame ) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Export data to csv file def rotating_polygon_iterator ( self ) -> None : \"\"\"Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Note: Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: * All laserlines are processed in batches of the defined `laser_step` * The laserline objects are initialized on demand unlike other senor setups where `preinitialized_frame` is set to True \"\"\" self . end_frame = int ( self . laser_origin_orientation_list [ - 1 ][ 0 ]) # Set End frame laserline_id = 0 #Iterate through laserlines in the given set while laserline_id < len ( self . laser_list ) - self . laser_step : logger . update_progress ( \"laserline\" , laserline_id / ( len ( self . laser_list ) - self . laser_step )) # Display progress on system console # Initialise laserlines if not self . preinitialized_frame : for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] sensor_object = bpy . data . objects [ self . sensor_name ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( laser_raydir ) laser_raydir . parent = laser laser . parent = sensor_object steps = np . arange ( self . start_frame , self . end_frame + self . frame_step , self . frame_step ) #Calcualate frame steps for n in range ( 0 , len ( steps ) - 1 ): start = steps [ n ] - self . start_frame end = min ( steps [ n + 1 ], self . end_frame ) - self . start_frame # Set orientation of laser sensor across the frame range for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) orientation = self . laser_origin_orientation_list [ i ][ - 3 :] bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) self . laser_object_group_frame_range_iterator ( start , end , laserline_id ) #Get intersections across the frame range # Unlink laserlines for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser ) bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser_raydir ) laserline_id += self . laser_step # Delete keyframes for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) def create_export_file ( self ): \"\"\"It calls export function creates a new csv file with the set `data_columns` writes in `w+` mode.\"\"\" self . export ([ self . data_columns ], 'w+' ) def export ( self , data : list , mode : str ): \"\"\"Creates or appends data to a pointcloud.csv file with the given data Args: data: Data to be exported in list form mode: Writing mode eg. `a+` or `w+` \"\"\" try : os . makedirs ( os . path . dirname ( self . out_file_name )) #Create a file if not exists except : None #Append or write data to file try : with open ( self . out_file_name , mode , newline = '' ) as write_obj : csv_writer = csv . writer ( write_obj ) for n in range ( len ( data )): row = data [ n ] csv_writer . writerow ( row ) except : None","title":"laser_sensor"},{"location":"modules/laser/#Modules.laser.laser_sensor.__init__","text":"Initialises all the variables. Calls model accuracy which creates error models for range , incidence and fixed errors . laser_origin_orientation_list is created which provides sensor orientation values (omega, phi and kappa) for each frame. Parameters: Name Type Description Default sensor_data json all parameters of the sensor required platform_data json all platform parameters required Source code in Modules\\laser.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def __init__ ( self , sensor_data : json , platform_data : json ) -> None : \"\"\" Initialises all the variables. Calls model accuracy which creates error models for `range`, `incidence` and `fixed errors`. `laser_origin_orientation_list` is created which provides sensor orientation values (omega, phi and kappa) for each frame. Args: sensor_data: all parameters of the sensor platform_data: all platform parameters \"\"\" self . laser_step = 100 #: int: The number of laser lines to process before exporting self . frame_step = 50 #: int: The number of frames to process before exporting self . data_accuracy = 8 #: int: Set last decimal place upto which all data needs to be rounded off self . sensor_data = sensor_data #: json: Get all sensor parameters self . platform_data = platform_data #: json: Get all platform parameters self . sensor_name = self . sensor_data [ \"sensor_name\" ] #: str: Sensor's name self . rotation_type = self . sensor_data [ \"rotation_type\" ] self . scanner_location = self . sensor_data [ \"platform\" ][ \"position\" ] try : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] except : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] self . prf = sensor_data [ \"parameters\" ][ \"prf\" ] self . sf = sensor_data [ \"parameters\" ][ \"sf\" ] self . start_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"start_fov\" ] self . end_vfov = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"end_fov\" ] self . positive_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"start_view_angle\" ] self . negative_hfov = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"end_view_angle\" ] self . sensor_range_min = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'min' ] self . sensor_range_max = self . sensor_data [ \"parameters\" ][ \"sensor_range\" ][ 'max' ] self . start_frame = self . platform_data [ \"render\" ][ \"start_frame\" ] self . end_frame = self . platform_data [ \"render\" ][ \"end_frame\" ] self . hfov = self . negative_hfov - self . positive_hfov # Calculate horizontal field of view self . horizontal_deviation_per_pulse = self . sf * self . hfov * self . number_of_channels / self . prf # Calculate horizontal deviation per pulse self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation self . out_file_name = self . platform_data [ 'render' ][ 'output_file_location' ] + \"/Sensor/point_cloud_\" + self . sensor_name + \".csv\" # Set output csv file name #: Initialize lists for error models self . fixed_error_model = [] self . model_range = [] self . range_error_model = [] self . incidence_angle_error_model = [] self . model_accuracy () # Create error models based on selection # Create sensor origin orientation list for each frame for each scanning pattern type self . laser_origin_orientation_list = [] if self . rotation_type == \"rotating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_r () if self . rotation_type == \"osscilating\" : self . pulses_per_frame = self . sensor_data [ \"render\" ][ \"pulses_per_frame\" ] self . deviation_per_frame = self . horizontal_deviation_per_pulse self . orientation_csv_static_o () if self . rotation_type == \"rotating_polygon\" : self . flying_height = self . sensor_data [ 'parameters' ][ 'horizontal_scanning' ][ 'mean_flying_height' ] self . orientation_csv_static_not_rotating () if self . rotation_type == \"flash\" : self . number_of_hor_channels = self . sensor_data [ \"parameters\" ][ \"horizontal_scanning\" ][ \"number_of_channels\" ] self . orientation_csv_static_not_rotating () self . laser_list = [] #List containing names of laser objects self . data_columns = [ \"//X\" , \"Y\" , \"Z\" , \"Time\" , \"Label\" , \"Instance_id\" , \"Incidence_angle\" , \"Sensor_name\" , \"Pulse_id\" , \"Channel_id\" , \"Rf\" , \"Gf\" , \"Bf\" , \"Af\" , \"Intensity\" ] #List of header names for exported csv file self . csv_export_list = [] #List containing interected points # Get all label values self . dict_data = global_data . bl_scene . label_dict self . dict_values = list ( self . dict_data . values ()) self . dict_keys = list ( self . dict_data . keys ()) global_data . bl_scene . all_data [ 'labels' ] = self . dict_data self . preinitialized_frame = False","title":"__init__()"},{"location":"modules/laser/#Modules.laser.laser_sensor.all_laserlines_frame_range_iterator","text":"Computes intersections for all channels across a given frame range and exports the data to csv file Parameters: Name Type Description Default start int Start frame required end int End Frame required Source code in Modules\\laser.py 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 def all_laserlines_frame_range_iterator ( self , start : int , end : int ): \"\"\"Computes intersections for all channels across a given frame range and exports the data to csv file Args: start: Start frame end: End Frame \"\"\" steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): csv_export_list = [] #Empty list to store the intersection data start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame #print (start_frame,end_frame,frame_number) # Set blender scene frame frame = int ( self . laser_origin_orientation_list [ frame_number ][ 0 ]) #print (frame) orientation = self . laser_origin_orientation_list [ frame_number ][ - 3 :] #print (orientation) bpy . context . scene . frame_set ( frame ) bpy . context . view_layer . update () # Update blender context bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Generating point cloud \" , frame_number / ( end - start )) # Display progress on system console for selected_laserline_id in range ( len ( self . laser_list )): # Iterate through all laserline objects #logger.update_progress(\"Generating point cloud \", ((frame_number-start_frame+ (selected_laserline_id/len(self.laser_list)))/(self.end_frame-self.start_frame))) # Display progress on system console intersection = self . laserline_currentframe_interaction ( frame , selected_laserline_id ) if intersection : csv_export_list . append ( intersection ) # Append data to export list #self.check_intersections_frame_range(start,end) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"location\" , frame = frame ) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame ) if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Export data to csv file","title":"all_laserlines_frame_range_iterator()"},{"location":"modules/laser/#Modules.laser.laser_sensor.check_intersection","text":"Finds out intersections for a laser vector starting from origin in the direction , upto the given distance . Note It looks for intersection untill a point with zero transparency is found Parameters: Name Type Description Default graph bpy . context Blender scene context required origin mathutils . Vector Location of origin required direction mathutils . Vector Location of direction vector required distance int Maximum range distance required Returns a tuple of the following values Type Description Boolean hit mathutils . Vector location mathutils . Vector normal int index int object list matrix float r float g float b float a float ir Source code in Modules\\laser.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def check_intersection ( self , graph : bpy . context , origin : mathutils . Vector , direction : mathutils . Vector , distance : int ) -> Tuple [ Boolean , mathutils . Vector , mathutils . Vector , int , int , list , float , float , float , float , float ]: \"\"\" Finds out intersections for a laser vector starting from `origin` in the `direction`, upto the given `distance`. Note: It looks for intersection untill a point with zero transparency is found Args: graph: Blender scene context origin: Location of origin direction: Location of direction vector distance: Maximum range distance Returns: Returns a tuple of the following values hit location normal index object matrix r g b a ir \"\"\" r , g , b , a , ir = 0 , 0 , 0 , 0 , 0 location = mathutils . Vector (( 0 , 0 , 0 )) object , matrix , normal , index = None , None , None , None hit = True while ( a == 0 and hit ): # iterate until intersection occurs on an opaque object hit , location , normal , index , object , matrix = bpy . context . scene . ray_cast ( graph , origin = origin , direction = direction , distance = distance ) if hit : try : # Get RGB information from image texture mesh = object . data face = mesh . polygons [ index ] slot = object . material_slots [ face . material_index ] material = slot . material verticesIndices = face . vertices texture_image_name = material . node_tree . nodes [ 'Image Texture' ] . image . name # Transform 3D world location to 2D location on image plane p1 , p2 , p3 = [ object . matrix_world @ object . data . vertices [ verticesIndices [ i ]] . co for i in range ( 3 )] uvMapIndices = face . loop_indices uvMap = object . data . uv_layers [ 'UVMap' ] uv1 = [ uvMap . data [ uvMapIndices [ 0 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 0 ]] . uv [ 1 ], 0 ] uv2 = [ uvMap . data [ uvMapIndices [ 1 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 1 ]] . uv [ 1 ], 0 ] uv3 = [ uvMap . data [ uvMapIndices [ 2 ]] . uv [ 0 ], uvMap . data [ uvMapIndices [ 2 ]] . uv [ 1 ], 0 ] transformed_location = mathutils . geometry . barycentric_transform ( location , p1 , p2 , p3 , uv1 , uv2 , uv3 ) #Get RGBA values from texture image img = bpy . data . images [ texture_image_name ] width , height = img . size [ 0 : 2 ] index = ((( int (( transformed_location [ 1 ] % 1 ) * height ) * width ) + int (( transformed_location [ 0 ] % 1 ) * width )) - 1 ) * 4 r , g , b , a = img . pixels [ index : index + 4 ] except : # Get RGB information from base colour material_layers = material . node_tree . nodes [ \"Principled BSDF\" ] . inputs r , g , b , a = material_layers [ 'Base Color' ] . default_value ir = ( r + g + b ) / ( 3 * 255 ) #IR value estimation # if a translucent object is found continue the ray ahead after the found point direction = location - origin distance = distance - direction . length origin = location + ( direction . normalized ()) direction = origin - location return ( hit , location , normal , index , object , matrix ,( r , g , b , a , ir ))","title":"check_intersection()"},{"location":"modules/laser/#Modules.laser.laser_sensor.create_export_file","text":"It calls export function creates a new csv file with the set data_columns writes in w+ mode. Source code in Modules\\laser.py 677 678 679 def create_export_file ( self ): \"\"\"It calls export function creates a new csv file with the set `data_columns` writes in `w+` mode.\"\"\" self . export ([ self . data_columns ], 'w+' )","title":"create_export_file()"},{"location":"modules/laser/#Modules.laser.laser_sensor.create_sensor_frame","text":"Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV Source code in Modules\\laser.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def create_sensor_frame ( self ): \"\"\"Creates a static frame for a laser sensor depending upon the number of channels in the vertical and horizontal FOV \"\"\" lidar_sensor_main = bpy . data . objects [ self . sensor_name ] # Get blender object with the given sensor name try : vertical_deviation = ( self . end_vfov - self . start_vfov ) / ( self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] - 1 ) # Deviation between each vertical channel vertical_deviations = np . arange ( self . start_vfov , self . end_vfov + 1 , vertical_deviation ) . tolist () # List of angle of deviation for each vertical channel except : vertical_deviations = [ 0.0 ] # Deviation for a single channel sensor horizontal_deviations = self . get_horizontal_deviation_angles () # Get a list of angle of deviation for each horizontal channel if self . rotation_type == \"rotating_polygon\" : self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] * len ( horizontal_deviations ) self . time_per_horizontal_dev = self . number_of_channels / self . prf # Calculate time per horizontal deviation for pulse in range ( len ( horizontal_deviations )): h_dev_angle = horizontal_deviations [ pulse ] # A deviation angle for current horizontal pulse for channel in range ( len ( vertical_deviations )): v_dev_angle = - vertical_deviations [ channel ] # A deviation angle for current vertical channel # Create a laser vector laser = bpy . data . objects . new ( \"laser_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) laser . empty_display_type = 'PLAIN_AXES' laser . empty_display_size = 0.001 laser . location = ( 0 , 0 , 0 ) # Create a laser direction vector l_dir = bpy . data . objects . new ( \"laser_dir_\" + self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel ), None ) l_dir . empty_display_type = 'PLAIN_AXES' l_dir . empty_display_size = 0.001 direction_vector_length = 1 l_dir . location = ( direction_vector_length , 0 , 0 ) # Link the laser vector objects to the current scene if self . preinitialized_frame == True : bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( l_dir ) l_dir . parent = laser laser . parent = lidar_sensor_main # Link the laser vector object to the sensor object laser . rotation_euler = ( 0 , math . radians ( v_dev_angle ), math . radians ( h_dev_angle )) # Rotate the laser vector according the vertical and horizontal deviation self . laser_list . append ( self . sensor_name + \"_\" + str ( pulse ) + \"_\" + str ( channel )) # Append the name of laser vector to the laser vector list bpy . context . view_layer . update () # Update blender scene context","title":"create_sensor_frame()"},{"location":"modules/laser/#Modules.laser.laser_sensor.export","text":"Creates or appends data to a pointcloud.csv file with the given data Parameters: Name Type Description Default data list Data to be exported in list form required mode str Writing mode eg. a+ or w+ required Source code in Modules\\laser.py 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 def export ( self , data : list , mode : str ): \"\"\"Creates or appends data to a pointcloud.csv file with the given data Args: data: Data to be exported in list form mode: Writing mode eg. `a+` or `w+` \"\"\" try : os . makedirs ( os . path . dirname ( self . out_file_name )) #Create a file if not exists except : None #Append or write data to file try : with open ( self . out_file_name , mode , newline = '' ) as write_obj : csv_writer = csv . writer ( write_obj ) for n in range ( len ( data )): row = data [ n ] csv_writer . writerow ( row ) except : None","title":"export()"},{"location":"modules/laser/#Modules.laser.laser_sensor.get_fixed_error","text":"Returns a random error value from the fixed error model Returns: Type Description list [error in x, error in y, error in z] Source code in Modules\\laser.py 210 211 212 213 214 215 216 217 218 219 220 def get_fixed_error ( self ) -> list : \"\"\"Returns a random error value from the fixed error model Returns: [error in x, error in y, error in z] \"\"\" error_x = random . choices ( self . fixed_error_model [ 0 ], k = 1 )[ 0 ] error_y = random . choices ( self . fixed_error_model [ 1 ], k = 1 )[ 0 ] error_z = random . choices ( self . fixed_error_model [ 2 ], k = 1 )[ 0 ] return [ error_x , error_y , error_z ]","title":"get_fixed_error()"},{"location":"modules/laser/#Modules.laser.laser_sensor.get_horizontal_deviation_angles","text":"Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Type Description np . ndarray Numpy list of angles of deviation for each laser line Source code in Modules\\laser.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def get_horizontal_deviation_angles ( self ) -> np . ndarray : \"\"\" Gives a list of deviation angles for the different sensor types - 1. Rotating and Osscilating - No deviation 2. Flash - Fixed angular deviation 3. Rotating Polygon - Fixed point spacing on ground Returns: Numpy list of angles of deviation for each laser line \"\"\" # For Rotatind and Osscilating if self . rotation_type == \"rotating\" or self . rotation_type == \"osscilating\" : angle_list = np . array ([ 0 ]) # For Flash if self . rotation_type == \"flash\" : angle_dev = ( self . negative_hfov - self . positive_hfov ) / ( self . number_of_hor_channels - 1 ) angle_list = np . arange ( self . positive_hfov , self . negative_hfov + 1 , angle_dev ) # For Rotating polygon style if self . rotation_type == \"rotating_polygon\" : angle_sublist = [ 0 ] #print (self.flying_height,math.tan(math.radians(self.hfov)),self.sf,self.prf) ground_spacing = self . flying_height * math . tan ( math . radians ( self . hfov )) * self . sf / self . prf # Calculate ground spacing if ( np . sign ( self . negative_hfov ) != np . sign ( self . positive_hfov )): for angle in [ math . radians ( self . negative_hfov ), math . radians ( self . positive_hfov )]: swath_width = self . flying_height * math . tan ( abs ( angle )) # Calculate Swath width n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( n * ground_spacing ) / self . flying_height )) ) * ( angle / abs ( angle )) #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) else : sign = ( self . negative_hfov / self . positive_hfov ) / abs (( self . negative_hfov / self . positive_hfov )) signed_hfov = abs ( math . radians ( self . negative_hfov ) - math . radians ( self . positive_hfov )) * ( sign ) swath_width = self . flying_height * math . tan ( abs ( signed_hfov )) initial_angle = min ( abs ( math . radians ( self . negative_hfov )), abs ( math . radians ( self . positive_hfov ))) initial_width = self . flying_height * math . tan ( abs ( initial_angle )) n = 1 #angle_sublist2 = [0] while n * ground_spacing <= swath_width : deviation_angle = ( math . degrees ( math . atan (( initial_width + ( n * ground_spacing )) / self . flying_height )) ) * sign #angle_sublist2.append(deviation_angle) angle_sublist . append ( deviation_angle ) n += 1 #angle_sublist.append(angle_sublist2) angle_list = np . unique ( np . array ( angle_sublist ) . flatten ()) # Rearrange array and remove duplicate angle values return angle_list","title":"get_horizontal_deviation_angles()"},{"location":"modules/laser/#Modules.laser.laser_sensor.get_incidence_error","text":"Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: Type Description np . ndarray List of errors for x, y, z - list(error in x, error in y, error in z) Source code in Modules\\laser.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_incidence_error ( self , angle : float ) -> np . ndarray : \"\"\"Returns a error for incidence angle Args: Incidence angle at which the point exists Returns: List of errors for x, y, z - list(error in x, error in y, error in z) \"\"\" try : accuracy_at_angle = self . incidence_angle_error_model [ np . where ( self . model_incidence_angle == int ( angle ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_angle = 0 indicence_angle_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_angle ), size = 1 )[ 0 ] # Computed error list return indicence_angle_error","title":"get_incidence_error()"},{"location":"modules/laser/#Modules.laser.laser_sensor.get_label_id","text":"Returns label id based on the intersected object's name. It looks for object_name in dict_values and returns its id from dict_keys. If object name is not found in the label dictionary, id is set to 999 Parameters: Name Type Description Default obj_name string Object's Name required Returns: Type Description int Label id Source code in Modules\\laser.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 def get_label_id ( self , obj_name : string ) -> int : \"\"\"Returns label id based on the intersected object's name. * It looks for object_name in dict_values and returns its id from dict_keys. * If object name is not found in the label dictionary, id is set to 999 Args: obj_name: Object's Name Returns: Label id \"\"\" try : label_id = self . dict_values . index ( obj_name . lower ()) label = self . dict_keys [ label_id ] except : label = 999 return ( label )","title":"get_label_id()"},{"location":"modules/laser/#Modules.laser.laser_sensor.get_range_error","text":"Returns a list of random values based on input range Generates random error from a normal distribution with a standard deviation for the given range from range_error_model Parameters: Name Type Description Default range float Range at which the point exists required Returns: Type Description np . ndarray Error in range Source code in Modules\\laser.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 def get_range_error ( self , range : float ) -> np . ndarray : \"\"\"Returns a list of random values based on input `range` Generates random error from a normal distribution with a standard deviation for the given `range` from `range_error_model` Args: range:Range at which the point exists Returns: Error in range \"\"\" try : accuracy_at_range = self . range_error_model [ np . where ( self . model_range == int ( range ))[ 0 ][ 0 ]] # Get accuracy for input range except : accuracy_at_range = 0 range_error = np . random . normal ( loc = 0 , scale = float ( accuracy_at_range ), size = 1 )[ 0 ] # Computed range error return range_error","title":"get_range_error()"},{"location":"modules/laser/#Modules.laser.laser_sensor.laser_object_group_frame_range_iterator","text":"Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Parameters: Name Type Description Default start int Start frame required end int End Frame required laserline_id int Id of the selected laserline required Source code in Modules\\laser.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 def laser_object_group_frame_range_iterator ( self , start : int , end : int , laserline_id : int ) -> None : \"\"\"Computes intersections for a number of channels = laser_step across a given frame range and exports the data to pointcloud.csv file Args: start: Start frame end: End Frame laserline_id: Id of the selected laserline \"\"\" bpy . context . view_layer . update () # Update blender context csv_export_list = [] #Empty list to store the intersection data steps = np . arange ( start , end + self . frame_step , self . frame_step ) for n in range ( 0 , len ( steps ) - 1 ): start_frame = steps [ n ] - start end_frame = min ( steps [ n + 1 ], end ) - self . start_frame for frame_number in range ( start_frame , end_frame ): #iterate from start frame to end frame # Set frame frame = int ( self . laser_origin_orientation_list [ frame_number - start ][ 0 ]) bpy . context . scene . frame_set ( frame ) for selected_laserline_id in range ( laserline_id , laserline_id + self . laser_step ): #iterate through laser line group if self . laserline_currentframe_interaction ( frame , selected_laserline_id ): csv_export_list . append ( self . laserline_currentframe_interaction ( frame , selected_laserline_id )) # Append data to export list if len ( csv_export_list ) > 0 : self . export ( csv_export_list , \"a+\" ) # Append data to csv file","title":"laser_object_group_frame_range_iterator()"},{"location":"modules/laser/#Modules.laser.laser_sensor.laserline_currentframe_interaction","text":"Computes intersections for a selected laserline on the given frame Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] Source code in Modules\\laser.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def laserline_currentframe_interaction ( self , frame : int , selected_laserline_id : int ) -> list : \"\"\"Computes intersections for a selected laserline on the given frame Args: frame (int), selected_laserline_id (int) Returns: [x,y,z,t,label,instance_id,incidence_angle,self.sensor_name,frame,channel_id,r,g,b,a,intensity] \"\"\" bpy . context . view_layer . update () # Update blender context # Get laser origin and direction locations ray_origin = bpy . context . scene . objects [ \"laser_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () ray_direction_pt = bpy . context . scene . objects [ \"laser_dir_\" + self . laser_list [ selected_laserline_id ]] . matrix_world . to_translation () graph = bpy . context . evaluated_depsgraph_get () # Get scene context hit , location , normal , index , object , matrix , colour = self . check_intersection ( graph , ray_origin , ray_direction_pt - ray_origin , self . sensor_range_max ) # Get intersction point with RGBIR # Calculate Range incident_ray = location - ray_origin range = incident_ray . length if hit and range > self . sensor_range_min : # Check if intersection occured and range is greater than minimum range # Calculate Incidence Angle normal *= - 1 incidence_angle = incident_ray . rotation_difference ( normal ) . angle # Get error values range_error = self . get_range_error ( range ) incidence_error = self . get_incidence_error ( incidence_angle ) fixed_error_list = self . get_fixed_error () # Compute erronous incidence angle # Compute erronous range erronous_range = range + range_error # Compute new location unit_incident_ray = incident_ray / range updated_incident_ray = unit_incident_ray * erronous_range + ray_origin location = updated_incident_ray # Compute final position x = round ( location [ 0 ] + fixed_error_list [ 0 ], self . data_accuracy ) y = round ( location [ 1 ] + fixed_error_list [ 1 ], self . data_accuracy ) z = round ( location [ 2 ] + fixed_error_list [ 2 ], self . data_accuracy ) t = frame * self . time_per_horizontal_dev pulse_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 2 ]) channel_id = int ( self . laser_list [ selected_laserline_id ] . split ( \"_\" )[ - 1 ]) r , g , b , a , ir = colour intensity = round ( ir * math . cos ( incidence_angle ) * 255 / ( range ** 2 ), self . data_accuracy ) label = str ( self . get_label_id ( object . name . split ( \".\" )[ 0 ])) try : instance_id = str ( object . name . split ( \".\" )[ 1 ]) except : instance_id = \"000\" #print (x,y,z) return ([ x , y , z , t , label , instance_id , incidence_angle , self . sensor_name , frame , channel_id , r , g , b , a , intensity ])","title":"laserline_currentframe_interaction()"},{"location":"modules/laser/#Modules.laser.laser_sensor.lidar_sensor_main","text":"Main class to handle creation of sensor frame and to check intersections Source code in Modules\\laser.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 def lidar_sensor_main ( self ) -> None : \"\"\"Main class to handle creation of sensor frame and to check intersections\"\"\" bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects global_data . bl_scene . all_data [ \"time\" ] = 0 export_json ( True ) # Export json file starttime = time . time () #Start time self . create_export_file () # Create output csv file with headers # Based on sensor type - create a sensor frame, then iterate over the previously create orientation list if self . rotation_type == \"rotating_polygon\" or self . rotation_type == \"flash\" : self . create_sensor_frame () self . rotating_polygon_iterator () if self . rotation_type == \"osscilating\" or self . rotation_type == \"rotating\" : self . preinitialized_frame = True self . create_sensor_frame () self . all_laserlines_frame_range_iterator ( self . start_frame , self . end_frame ) endtime = time . time () #End time global_data . bl_scene . all_data [ \"time\" ] = endtime - starttime export_json ( True ) # Export json file bpy . ops . outliner . orphans_purge ( do_local_ids = True , do_linked_ids = True , do_recursive = False ) # Delete all unlinked blender objects for next run","title":"lidar_sensor_main()"},{"location":"modules/laser/#Modules.laser.laser_sensor.model_accuracy","text":"Generates a accuracy model based on the error type Source code in Modules\\laser.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def model_accuracy ( self ) -> None : \"\"\"Generates a accuracy model based on the error type \"\"\" if ( \"fixed\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Genrates a list of random errors based on the standard dev values from user try : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'x' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'y' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] except : fixed_error_x = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_y = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'xy' ] fixed_error_z = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'fixed' ][ 'z' ] self . fixed_error_model = [ np . random . normal ( loc = 0 , scale = float ( fixed_error_x ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_y ), size = 10000 ), np . random . normal ( loc = 0 , scale = float ( fixed_error_z ), size = 10000 )] if ( \"range\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree range vs accuracy curve self . model_range = np . linspace ( self . sensor_range_min , self . sensor_range_max , self . sensor_range_max , dtype = int ) range_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a1' ] # User input for coefficient of x^2 range_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a2' ] # User input for coefficient of x range_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ 'range' ][ 'a3' ] # User input for error at minimum range self . range_error_model = ( range_a1 * ( self . model_range ** 2 )) + ( range_a2 * self . model_range ) + range_a3 if ( \"incidence\" in self . sensor_data [ \"parameters\" ][ \"error\" ]): # Creates a a 2 degree incidence angle vs accuracy curve min_incidence_angle = 0 max_incidence_angle = 1.58 step = 0.01 self . model_incidence_angle = np . arange ( min_incidence_angle , max_incidence_angle , step ) incidence_a1 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a1' ] # User input for coefficient of x^2 incidence_a2 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a2' ] # User input for coefficient of x incidence_a3 = self . sensor_data [ \"parameters\" ][ \"error\" ][ \"incidence\" ][ 'a3' ] # User input for error at minimum range self . incidence_angle_error_model = ( incidence_a1 * ( self . model_incidence_angle ** 2 )) + ( incidence_a2 * self . model_incidence_angle ) + incidence_a3","title":"model_accuracy()"},{"location":"modules/laser/#Modules.laser.laser_sensor.orientation_csv_static_not_rotating","text":"Creates a positition orientation list for a stationary non rotating type of scanner Source code in Modules\\laser.py 340 341 342 343 344 345 346 def orientation_csv_static_not_rotating ( self ): \"\"\"Creates a positition orientation list for a stationary non rotating type of scanner \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): self . laser_origin_orientation_list . append ([ i , 0 , 0 , 0 ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list )","title":"orientation_csv_static_not_rotating()"},{"location":"modules/laser/#Modules.laser.laser_sensor.orientation_csv_static_o","text":"Generates a list for orientation values for a Osscilating type sensor Source code in Modules\\laser.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def orientation_csv_static_o ( self ): \"\"\"Generates a list for orientation values for a Osscilating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = i * self . deviation_per_frame if int ( dev_angle / self . hfov ) % 2 == 0 : dev_angle = dev_angle % self . hfov else : dev_angle = self . hfov - ( dev_angle % self . hfov ) dev_angle += self . positive_hfov self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list )","title":"orientation_csv_static_o()"},{"location":"modules/laser/#Modules.laser.laser_sensor.orientation_csv_static_r","text":"Generates a list for orientation values for a rotating type sensor Source code in Modules\\laser.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 def orientation_csv_static_r ( self ): \"\"\"Generates a list for orientation values for a rotating type sensor \"\"\" self . laser_origin_orientation_list = [] #Empty list to store the frame and orientation values for i in range ( self . start_frame , self . end_frame ): dev_angle = ( i * self . deviation_per_frame ) + self . positive_hfov if ( dev_angle % 360 < self . negative_hfov ): dev_angle = dev_angle % 360 self . laser_origin_orientation_list . append ([ i , 0 , 0 , dev_angle ]) else : self . laser_origin_orientation_list . append ([ i , \"skip\" , \"skip\" , \"skip\" ]) # Skip laser line generation while out of FOV self . laser_origin_orientation_list = np . array ( self . laser_origin_orientation_list )","title":"orientation_csv_static_r()"},{"location":"modules/laser/#Modules.laser.laser_sensor.rotating_polygon_iterator","text":"Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: All laserlines are processed in batches of the defined laser_step The laserline objects are initialized on demand unlike other senor setups where preinitialized_frame is set to True Source code in Modules\\laser.py 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 def rotating_polygon_iterator ( self ) -> None : \"\"\"Iterates through all laserlines and frames - with initializing a set of laserlines and checking interesections for sets of frames Note: Since there are large number of laserlines for a rotating polygon type sensor following modifications are made: * All laserlines are processed in batches of the defined `laser_step` * The laserline objects are initialized on demand unlike other senor setups where `preinitialized_frame` is set to True \"\"\" self . end_frame = int ( self . laser_origin_orientation_list [ - 1 ][ 0 ]) # Set End frame laserline_id = 0 #Iterate through laserlines in the given set while laserline_id < len ( self . laser_list ) - self . laser_step : logger . update_progress ( \"laserline\" , laserline_id / ( len ( self . laser_list ) - self . laser_step )) # Display progress on system console # Initialise laserlines if not self . preinitialized_frame : for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] sensor_object = bpy . data . objects [ self . sensor_name ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . link ( laser ) bpy . data . collections [ 'Sensor' ] . objects . link ( laser_raydir ) laser_raydir . parent = laser laser . parent = sensor_object steps = np . arange ( self . start_frame , self . end_frame + self . frame_step , self . frame_step ) #Calcualate frame steps for n in range ( 0 , len ( steps ) - 1 ): start = steps [ n ] - self . start_frame end = min ( steps [ n + 1 ], self . end_frame ) - self . start_frame # Set orientation of laser sensor across the frame range for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) orientation = self . laser_origin_orientation_list [ i ][ - 3 :] bpy . context . scene . objects [ self . sensor_name ] . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . context . scene . objects [ self . sensor_name ] . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) self . laser_object_group_frame_range_iterator ( start , end , laserline_id ) #Get intersections across the frame range # Unlink laserlines for i in range ( laserline_id , laserline_id + self . laser_step ): l_obj = \"laser_\" + self . laser_list [ i ] l_raydir = \"laser_dir_\" + self . laser_list [ i ] laser = bpy . data . objects [ l_obj ] laser_raydir = bpy . data . objects [ l_raydir ] bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser ) bpy . data . collections [ 'Sensor' ] . objects . unlink ( laser_raydir ) laserline_id += self . laser_step # Delete keyframes for i in range ( start , end ): frame = int ( self . laser_origin_orientation_list [ i ][ 0 ]) bpy . context . scene . objects [ self . sensor_name ] . keyframe_delete ( data_path = \"rotation_euler\" , frame = frame )","title":"rotating_polygon_iterator()"},{"location":"modules/laser/#Modules.laser.laser_sensor.visulize_sensor_frame","text":"Visulises the sensor frame Source code in Modules\\laser.py 168 169 170 171 172 def visulize_sensor_frame ( self ) -> None : \"\"\"Visulises the sensor frame \"\"\" self . preinitialized_frame = True self . create_sensor_frame ()","title":"visulize_sensor_frame()"},{"location":"modules/others/","text":"Others","title":"Others"},{"location":"modules/others/#others","text":"","title":"Others"},{"location":"modules/platform/","text":"Platform Module platform_class Platform class. It lets us add sensors and cameras Source code in Modules\\limulator_platform.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class platform_class : \"\"\"Platform class. It lets us add sensors and cameras Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" def __init__ ( self , platform_data , sensor_data ): \"\"\"Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" self . platform_data = platform_data # All platform parameters self . sensor_data = sensor_data # All Sensor parameters # Create a empty blender object for the platform self . platform = bpy . data . objects . new ( \"platform\" , None ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . platform ) # Set platform orientation default orientation platform_orientation = self . platform_data [ 'platform' ][ 'orientation' ] self . platform . delta_rotation_euler = ( math . radians ( float ( platform_orientation [ 0 ])), math . radians ( float ( platform_orientation [ 1 ])), math . radians ( float ( platform_orientation [ 2 ]))) # Set platform position and orientation based on an external csv file if ( \"trajectory_file\" in self . platform_data ): logger . update_progress ( \"Creating platform (Trajectory)\" , 0 ) self . trajectory_path = platform_data [ 'render' ][ 'output_file_location' ] + \"/\" + self . platform_data [ \"trajectory_file\" ] # Calculate time per frame based on the prf and number of channels self . prf = self . sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] time_per_frame_sensor = self . number_of_channels / self . prf with open ( self . trajectory_path , mode = 'r' ) as csv_file : csv_reader = csv . reader ( csv_file , delimiter = ',' ) next ( csv_reader ) for row in csv_reader : location = ( float ( row [ 0 ]), float ( row [ 1 ]), float ( row [ 2 ])) orientation = ( float ( row [ 3 ]), float ( row [ 4 ]), float ( row [ 4 ])) time = float ( row [ 6 ]) frame = int ( time / time_per_frame_sensor ) self . platform . location = location self . platform . rotation_euler = ( math . radians ( orientation [ 0 ]), math . radians ( orientation [ 1 ]), math . radians ( orientation [ 2 ])) self . platform . keyframe_insert ( data_path = \"location\" , frame = frame ) self . platform . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Creating platform (Trajectory)\" , 1 ) # Link platform to an existing blender object if ( \"platform_vehicle_name\" in self . platform_data ): logger . update_progress ( \"Creating platform (blender object)\" , 0 ) platform_vehicle_object_name = self . platform_data [ \"platform_vehicle_name\" ] platform_vehicle_object = bpy . data . objects [ platform_vehicle_object_name ] self . platform . parent = platform_vehicle_object logger . update_progress ( \"Creating platform (blender object)\" , 1 ) def add_camera ( self , camera_data ): \"\"\"Creates a camera child object inside platform object Args: Platform data (Json) and camera data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Camera\" , 0 ) self . camera_name = camera_data [ \"camera_name\" ] camera = bpy . data . objects . new ( self . camera_name , None ) camera . location = camera_data [ 'platform' ][ 'position' ] orientation = camera_data [ 'platform' ][ 'orientation' ] camera . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( camera ) camera . parent = self . platform logger . update_progress ( \"Adding Camera\" , 1 ) def add_sensor ( self , sensor_data ): \"\"\"Creates a sensor child object inside platform object Args: Platform data (Json) and sensor data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Sensor\" , 0 ) self . sensor_name = sensor_data [ \"sensor_name\" ] sensor_parent = bpy . data . objects . new ( self . sensor_name , None ) orientation = sensor_data [ 'platform' ][ 'orientation' ] sensor_parent . delta_location = sensor_data [ 'platform' ][ 'position' ] sensor_parent . delta_rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( sensor_parent ) sensor_parent . parent = self . platform logger . update_progress ( \"Adding Sensor\" , 1 ) __init__ ( platform_data , sensor_data ) Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Source code in Modules\\limulator_platform.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , platform_data , sensor_data ): \"\"\"Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" self . platform_data = platform_data # All platform parameters self . sensor_data = sensor_data # All Sensor parameters # Create a empty blender object for the platform self . platform = bpy . data . objects . new ( \"platform\" , None ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . platform ) # Set platform orientation default orientation platform_orientation = self . platform_data [ 'platform' ][ 'orientation' ] self . platform . delta_rotation_euler = ( math . radians ( float ( platform_orientation [ 0 ])), math . radians ( float ( platform_orientation [ 1 ])), math . radians ( float ( platform_orientation [ 2 ]))) # Set platform position and orientation based on an external csv file if ( \"trajectory_file\" in self . platform_data ): logger . update_progress ( \"Creating platform (Trajectory)\" , 0 ) self . trajectory_path = platform_data [ 'render' ][ 'output_file_location' ] + \"/\" + self . platform_data [ \"trajectory_file\" ] # Calculate time per frame based on the prf and number of channels self . prf = self . sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] time_per_frame_sensor = self . number_of_channels / self . prf with open ( self . trajectory_path , mode = 'r' ) as csv_file : csv_reader = csv . reader ( csv_file , delimiter = ',' ) next ( csv_reader ) for row in csv_reader : location = ( float ( row [ 0 ]), float ( row [ 1 ]), float ( row [ 2 ])) orientation = ( float ( row [ 3 ]), float ( row [ 4 ]), float ( row [ 4 ])) time = float ( row [ 6 ]) frame = int ( time / time_per_frame_sensor ) self . platform . location = location self . platform . rotation_euler = ( math . radians ( orientation [ 0 ]), math . radians ( orientation [ 1 ]), math . radians ( orientation [ 2 ])) self . platform . keyframe_insert ( data_path = \"location\" , frame = frame ) self . platform . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Creating platform (Trajectory)\" , 1 ) # Link platform to an existing blender object if ( \"platform_vehicle_name\" in self . platform_data ): logger . update_progress ( \"Creating platform (blender object)\" , 0 ) platform_vehicle_object_name = self . platform_data [ \"platform_vehicle_name\" ] platform_vehicle_object = bpy . data . objects [ platform_vehicle_object_name ] self . platform . parent = platform_vehicle_object logger . update_progress ( \"Creating platform (blender object)\" , 1 ) add_camera ( camera_data ) Creates a camera child object inside platform object Source code in Modules\\limulator_platform.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def add_camera ( self , camera_data ): \"\"\"Creates a camera child object inside platform object Args: Platform data (Json) and camera data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Camera\" , 0 ) self . camera_name = camera_data [ \"camera_name\" ] camera = bpy . data . objects . new ( self . camera_name , None ) camera . location = camera_data [ 'platform' ][ 'position' ] orientation = camera_data [ 'platform' ][ 'orientation' ] camera . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( camera ) camera . parent = self . platform logger . update_progress ( \"Adding Camera\" , 1 ) add_sensor ( sensor_data ) Creates a sensor child object inside platform object Source code in Modules\\limulator_platform.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_sensor ( self , sensor_data ): \"\"\"Creates a sensor child object inside platform object Args: Platform data (Json) and sensor data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Sensor\" , 0 ) self . sensor_name = sensor_data [ \"sensor_name\" ] sensor_parent = bpy . data . objects . new ( self . sensor_name , None ) orientation = sensor_data [ 'platform' ][ 'orientation' ] sensor_parent . delta_location = sensor_data [ 'platform' ][ 'position' ] sensor_parent . delta_rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( sensor_parent ) sensor_parent . parent = self . platform logger . update_progress ( \"Adding Sensor\" , 1 )","title":"Platform Module"},{"location":"modules/platform/#platform-module","text":"","title":"Platform Module"},{"location":"modules/platform/#Modules.limulator_platform.platform_class","text":"Platform class. It lets us add sensors and cameras Source code in Modules\\limulator_platform.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class platform_class : \"\"\"Platform class. It lets us add sensors and cameras Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" def __init__ ( self , platform_data , sensor_data ): \"\"\"Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" self . platform_data = platform_data # All platform parameters self . sensor_data = sensor_data # All Sensor parameters # Create a empty blender object for the platform self . platform = bpy . data . objects . new ( \"platform\" , None ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . platform ) # Set platform orientation default orientation platform_orientation = self . platform_data [ 'platform' ][ 'orientation' ] self . platform . delta_rotation_euler = ( math . radians ( float ( platform_orientation [ 0 ])), math . radians ( float ( platform_orientation [ 1 ])), math . radians ( float ( platform_orientation [ 2 ]))) # Set platform position and orientation based on an external csv file if ( \"trajectory_file\" in self . platform_data ): logger . update_progress ( \"Creating platform (Trajectory)\" , 0 ) self . trajectory_path = platform_data [ 'render' ][ 'output_file_location' ] + \"/\" + self . platform_data [ \"trajectory_file\" ] # Calculate time per frame based on the prf and number of channels self . prf = self . sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] time_per_frame_sensor = self . number_of_channels / self . prf with open ( self . trajectory_path , mode = 'r' ) as csv_file : csv_reader = csv . reader ( csv_file , delimiter = ',' ) next ( csv_reader ) for row in csv_reader : location = ( float ( row [ 0 ]), float ( row [ 1 ]), float ( row [ 2 ])) orientation = ( float ( row [ 3 ]), float ( row [ 4 ]), float ( row [ 4 ])) time = float ( row [ 6 ]) frame = int ( time / time_per_frame_sensor ) self . platform . location = location self . platform . rotation_euler = ( math . radians ( orientation [ 0 ]), math . radians ( orientation [ 1 ]), math . radians ( orientation [ 2 ])) self . platform . keyframe_insert ( data_path = \"location\" , frame = frame ) self . platform . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Creating platform (Trajectory)\" , 1 ) # Link platform to an existing blender object if ( \"platform_vehicle_name\" in self . platform_data ): logger . update_progress ( \"Creating platform (blender object)\" , 0 ) platform_vehicle_object_name = self . platform_data [ \"platform_vehicle_name\" ] platform_vehicle_object = bpy . data . objects [ platform_vehicle_object_name ] self . platform . parent = platform_vehicle_object logger . update_progress ( \"Creating platform (blender object)\" , 1 ) def add_camera ( self , camera_data ): \"\"\"Creates a camera child object inside platform object Args: Platform data (Json) and camera data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Camera\" , 0 ) self . camera_name = camera_data [ \"camera_name\" ] camera = bpy . data . objects . new ( self . camera_name , None ) camera . location = camera_data [ 'platform' ][ 'position' ] orientation = camera_data [ 'platform' ][ 'orientation' ] camera . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( camera ) camera . parent = self . platform logger . update_progress ( \"Adding Camera\" , 1 ) def add_sensor ( self , sensor_data ): \"\"\"Creates a sensor child object inside platform object Args: Platform data (Json) and sensor data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Sensor\" , 0 ) self . sensor_name = sensor_data [ \"sensor_name\" ] sensor_parent = bpy . data . objects . new ( self . sensor_name , None ) orientation = sensor_data [ 'platform' ][ 'orientation' ] sensor_parent . delta_location = sensor_data [ 'platform' ][ 'position' ] sensor_parent . delta_rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( sensor_parent ) sensor_parent . parent = self . platform logger . update_progress ( \"Adding Sensor\" , 1 )","title":"platform_class"},{"location":"modules/platform/#Modules.limulator_platform.platform_class.__init__","text":"Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Source code in Modules\\limulator_platform.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , platform_data , sensor_data ): \"\"\"Initialize and create a platform object in Blender Scene. If a trajectory file is avaialable animates the platform based on the position and orientation at each frame Else it links the platform to a mentioned blender object Args: Platform data (Json) and Sensor data (Json) Returns: None \"\"\" self . platform_data = platform_data # All platform parameters self . sensor_data = sensor_data # All Sensor parameters # Create a empty blender object for the platform self . platform = bpy . data . objects . new ( \"platform\" , None ) bpy . data . collections [ 'Sensor' ] . objects . link ( self . platform ) # Set platform orientation default orientation platform_orientation = self . platform_data [ 'platform' ][ 'orientation' ] self . platform . delta_rotation_euler = ( math . radians ( float ( platform_orientation [ 0 ])), math . radians ( float ( platform_orientation [ 1 ])), math . radians ( float ( platform_orientation [ 2 ]))) # Set platform position and orientation based on an external csv file if ( \"trajectory_file\" in self . platform_data ): logger . update_progress ( \"Creating platform (Trajectory)\" , 0 ) self . trajectory_path = platform_data [ 'render' ][ 'output_file_location' ] + \"/\" + self . platform_data [ \"trajectory_file\" ] # Calculate time per frame based on the prf and number of channels self . prf = self . sensor_data [ \"parameters\" ][ \"prf\" ] self . number_of_channels = self . sensor_data [ \"parameters\" ][ \"vertical_scanning\" ][ \"number_of_channels\" ] time_per_frame_sensor = self . number_of_channels / self . prf with open ( self . trajectory_path , mode = 'r' ) as csv_file : csv_reader = csv . reader ( csv_file , delimiter = ',' ) next ( csv_reader ) for row in csv_reader : location = ( float ( row [ 0 ]), float ( row [ 1 ]), float ( row [ 2 ])) orientation = ( float ( row [ 3 ]), float ( row [ 4 ]), float ( row [ 4 ])) time = float ( row [ 6 ]) frame = int ( time / time_per_frame_sensor ) self . platform . location = location self . platform . rotation_euler = ( math . radians ( orientation [ 0 ]), math . radians ( orientation [ 1 ]), math . radians ( orientation [ 2 ])) self . platform . keyframe_insert ( data_path = \"location\" , frame = frame ) self . platform . keyframe_insert ( data_path = \"rotation_euler\" , frame = frame ) logger . update_progress ( \"Creating platform (Trajectory)\" , 1 ) # Link platform to an existing blender object if ( \"platform_vehicle_name\" in self . platform_data ): logger . update_progress ( \"Creating platform (blender object)\" , 0 ) platform_vehicle_object_name = self . platform_data [ \"platform_vehicle_name\" ] platform_vehicle_object = bpy . data . objects [ platform_vehicle_object_name ] self . platform . parent = platform_vehicle_object logger . update_progress ( \"Creating platform (blender object)\" , 1 )","title":"__init__()"},{"location":"modules/platform/#Modules.limulator_platform.platform_class.add_camera","text":"Creates a camera child object inside platform object Source code in Modules\\limulator_platform.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def add_camera ( self , camera_data ): \"\"\"Creates a camera child object inside platform object Args: Platform data (Json) and camera data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Camera\" , 0 ) self . camera_name = camera_data [ \"camera_name\" ] camera = bpy . data . objects . new ( self . camera_name , None ) camera . location = camera_data [ 'platform' ][ 'position' ] orientation = camera_data [ 'platform' ][ 'orientation' ] camera . rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( camera ) camera . parent = self . platform logger . update_progress ( \"Adding Camera\" , 1 )","title":"add_camera()"},{"location":"modules/platform/#Modules.limulator_platform.platform_class.add_sensor","text":"Creates a sensor child object inside platform object Source code in Modules\\limulator_platform.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def add_sensor ( self , sensor_data ): \"\"\"Creates a sensor child object inside platform object Args: Platform data (Json) and sensor data (Json) Returns: None \"\"\" logger . update_progress ( \"Adding Sensor\" , 0 ) self . sensor_name = sensor_data [ \"sensor_name\" ] sensor_parent = bpy . data . objects . new ( self . sensor_name , None ) orientation = sensor_data [ 'platform' ][ 'orientation' ] sensor_parent . delta_location = sensor_data [ 'platform' ][ 'position' ] sensor_parent . delta_rotation_euler = ( math . radians ( float ( orientation [ 0 ])), math . radians ( float ( orientation [ 1 ])), math . radians ( float ( orientation [ 2 ]))) bpy . data . collections [ 'Sensor' ] . objects . link ( sensor_parent ) sensor_parent . parent = self . platform logger . update_progress ( \"Adding Sensor\" , 1 )","title":"add_sensor()"},{"location":"modules/server_processing/","text":"Server Processing","title":"Server Processing"},{"location":"modules/server_processing/#server-processing","text":"","title":"Server Processing"},{"location":"modules/ui/","text":"UI Module LIST_OT_DeleteItem Bases: Operator Delete the selected item from the list. Source code in Source Code\\main2.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 class LIST_OT_DeleteItem ( Operator ): \"\"\"Delete the selected item from the list.\"\"\" bl_idname = \"my_list.delete_item\" bl_label = \"Deletes an item\" @classmethod def poll ( cls , context ): return context . scene . my_list def execute ( self , context ): my_list = context . scene . my_list index = context . scene . list_index my_list . remove ( index ) context . scene . list_index = min ( max ( 0 , index - 1 ), len ( my_list ) - 1 ) return { 'FINISHED' } LIST_OT_DeleteLabelItem Bases: Operator Delete the selected item from the list. Source code in Source Code\\main2.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 class LIST_OT_DeleteLabelItem ( Operator ): \"\"\"Delete the selected item from the list.\"\"\" bl_idname = \"label_list.delete_item\" bl_label = \"Deletes an label\" @classmethod def poll ( cls , context ): return context . scene . label_list def execute ( self , context ): label_list = context . scene . label_list index = context . scene . label_list_index label_list . remove ( index ) context . scene . label_list_index = min ( max ( 0 , index - 1 ), len ( label_list ) - 1 ) return { 'FINISHED' } LIST_OT_EmptyLabelList Bases: Operator Reevaluates the Label list. Source code in Source Code\\main2.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 class LIST_OT_EmptyLabelList ( Operator ): \"\"\"Reevaluates the Label list.\"\"\" bl_idname = \"label_list.emptylist\" bl_label = \"Reevaluates all elements in Label list\" @classmethod def poll ( cls , context ): return context . scene . label_list def execute ( self , context ): label_list = context . scene . label_list index = 0 while ( index < len ( label_list )): label_list . remove ( index ) context . scene . label_list_index = min ( max ( 0 , index - 1 ), len ( label_list ) - 1 ) try : all_objects = bpy . data . collections [ 'Input' ] . all_objects . values () labels = [] for i in all_objects : labels . append ( i . name . split ( \".\" )[ 0 ]) np_label = np . unique ( np . array ( labels )) global_data . bl_scene . label_dict = {} bpy . context . scene . label_list_index = 0 for n in range ( len ( np_label )): global_data . bl_scene . label_dict [ n ] = np_label [ n ] . lower () bpy . context . scene . label_list . add () bpy . context . scene . label_list [ n ] . name = np_label [ n ] . lower () bpy . context . scene . label_list [ n ] . value = str ( n ) bpy . context . scene . label_list_index += 1 return { 'FINISHED' } except : return { 'CANCELLED' } LIST_OT_ExportLabelList Bases: Operator Exports the Label list. Source code in Source Code\\main2.py 604 605 606 607 608 609 610 611 612 613 614 class LIST_OT_ExportLabelList ( Operator ): \"\"\"Exports the Label list.\"\"\" bl_idname = \"label_list.export\" bl_label = \"Exports all elements in Label list\" def execute ( self , context ): global_data . bl_scene . label_file_path = os . path . dirname ( bpy . data . filepath ) + \"/label_dict.json\" with open ( global_data . bl_scene . label_file_path , \"w\" ) as outfile : json . dump ( global_data . bl_scene . label_dict , outfile ) return { 'FINISHED' } LIST_OT_MoveItem Bases: Operator Move an item in the list. Source code in Source Code\\main2.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 class LIST_OT_MoveItem ( Operator ): \"\"\"Move an item in the list.\"\"\" bl_idname = \"my_list.move_item\" bl_label = \"Move an item in the list\" direction : bpy . props . EnumProperty ( items = (( 'UP' , 'Up' , \"\" ), ( 'DOWN' , 'Down' , \"\" ),)) @classmethod def poll ( cls , context ): return context . scene . my_list def move_index ( self ): \"\"\" Move index of an item render queue while clamping it. \"\"\" index = bpy . context . scene . list_index list_length = len ( bpy . context . scene . my_list ) - 1 # (index starts at 0) new_index = index + ( - 1 if self . direction == 'UP' else 1 ) bpy . context . scene . list_index = max ( 0 , min ( new_index , list_length )) def execute ( self , context ): my_list = context . scene . my_list index = context . scene . list_index neighbor = index + ( - 1 if self . direction == 'UP' else 1 ) my_list . move ( neighbor , index ) self . move_index () return { 'FINISHED' } move_index () Move index of an item render queue while clamping it. Source code in Source Code\\main2.py 482 483 484 485 486 487 488 489 def move_index ( self ): \"\"\" Move index of an item render queue while clamping it. \"\"\" index = bpy . context . scene . list_index list_length = len ( bpy . context . scene . my_list ) - 1 # (index starts at 0) new_index = index + ( - 1 if self . direction == 'UP' else 1 ) bpy . context . scene . list_index = max ( 0 , min ( new_index , list_length )) LIST_OT_NewItem Bases: Operator Add a new item to the list. Source code in Source Code\\main2.py 440 441 442 443 444 445 446 447 448 class LIST_OT_NewItem ( Operator ): \"\"\"Add a new item to the list.\"\"\" bl_idname = \"my_list.new_item\" bl_label = \"Add a new item\" def execute ( self , context ): context . scene . my_list . add () return { 'FINISHED' } LIST_OT_NewLabelItem Bases: Operator Add a new label to list. Source code in Source Code\\main2.py 535 536 537 538 539 540 541 542 543 class LIST_OT_NewLabelItem ( Operator ): \"\"\"Add a new label to list.\"\"\" bl_idname = \"label_list.new_item\" bl_label = \"Add a new label\" def execute ( self , context ): context . scene . label_list . add () return { 'FINISHED' } LabelListItem Bases: PropertyGroup Group of properties representing an label item in the list. Source code in Source Code\\main2.py 501 502 503 504 505 506 507 508 509 510 511 512 513 class LabelListItem ( PropertyGroup ): \"\"\"Group of properties representing an label item in the list.\"\"\" name : StringProperty ( name = \"Name\" , description = \"Object Name\" , default = \"\" ) value : StringProperty ( name = \"Value\" , description = \"\" , default = \"999\" ) ListItem Bases: PropertyGroup Group of properties representing an item in the list. Source code in Source Code\\main2.py 406 407 408 409 410 411 412 413 414 415 416 417 418 class ListItem ( PropertyGroup ): \"\"\"Group of properties representing an item in the list.\"\"\" name : StringProperty ( name = \"Name\" , description = \"A name for this item\" , default = \"List Item\" ) random_prop : StringProperty ( name = \"JSON Path\" , description = \"\" , default = \"*.json\" , subtype = 'FILE_PATH' ) MY_UL_List Bases: UIList Demo UIList. Source code in Source Code\\main2.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 class MY_UL_List ( UIList ): \"\"\"Demo UIList.\"\"\" def draw_item ( self , context , layout , data , item , icon , active_data , active_propname , index ): # We could write some code to decide which icon to use here... #custom_icon = 'OBJECT_DATAMODE' # Make sure your code supports all 3 layout types if self . layout_type in { 'DEFAULT' , 'COMPACT' }: #layout.label(text=item.name, icon = custom_icon) layout . label ( text = item . name ) layout . label ( text = item . random_prop ) elif self . layout_type in { 'GRID' }: layout . alignment = 'CENTER' #layout.label(text=\"\", icon = custom_icon) layout . label ( text = \"\" ) SCENE_LABEL_List Bases: UIList Display Labels Source code in Source Code\\main2.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 class SCENE_LABEL_List ( UIList ): \"\"\"Display Labels\"\"\" def draw_item ( self , context , layout , data , item , icon , active_data , active_propname , index ): # We could write some code to decide which icon to use here... #custom_icon = 'OBJECT_DATAMODE' # Make sure your code supports all 3 layout types if self . layout_type in { 'DEFAULT' , 'COMPACT' }: #layout.label(text=item.name, icon = custom_icon) layout . label ( text = item . name ) layout . label ( text = item . value ) elif self . layout_type in { 'GRID' }: layout . alignment = 'CENTER' #layout.label(text=\"\", icon = custom_icon) layout . label ( text = \"\" ) createNew ( sensor_count , camera_count ) Creates a empty json structure for a new platform design Args: sensor_count (int) - Count of the lidar sensors to be added camera_count (int) - Count of the camera sensors to be added Source code in Source Code\\main2.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def createNew ( sensor_count , camera_count ): \"\"\" Creates a empty json structure for a new platform design Args: sensor_count (int) - Count of the lidar sensors to be added camera_count (int) - Count of the camera sensors to be added Returns: None \"\"\" global_data . bl_scene . all_data = { \"platform_data\" :{}, \"sensors\" :{}, \"cameras\" : {} } sensor_data = {} camera_data = {} for sn in range ( 1 , sensor_count + 1 ): sensor_data [ str ( sn )] = {} for cn in range ( 1 , camera_count + 1 ): camera_data [ str ( cn )] = {} global_data . bl_scene . all_data [ \"sensors\" ] = sensor_data global_data . bl_scene . all_data [ \"cameras\" ] = camera_data delete_platforms () Deletes all pre generated sensor objects Returns: None Source code in Source Code\\main2.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def delete_platforms (): \"\"\"Deletes all pre generated sensor objects Args: self Returns: None \"\"\" try : coll = bpy . data . collections . get ( \"Sensor\" ) obs = [ o for o in coll . objects ] n = len ( obs ) logger . update_progress ( \"Deleting existing platforms\" , 0 ) while obs : logger . update_progress ( \"Deleting existing platforms\" , ( 1 - len ( obs ) / n )) bpy . data . objects . remove ( obs . pop (), do_unlink = True ) except : new_col = bpy . data . collections . new ( name = \"Sensor\" ) bpy . context . scene . collection . children . link ( new_col ) export_json ( override = False ) Exports json file containing all platform, lidar and camera parameters to a given location or overrides a given json file with new data Source code in Source Code\\main2.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def export_json ( override = False ): \"\"\" Exports json file containing all platform, lidar and camera parameters to a given location or overrides a given json file with new data Args: None Returns: None \"\"\" if global_data . bl_scene . folder_path != \"\" : # For Exporting a new JSON file on the given folder path print ( \"Exporting json at\" , global_data . bl_scene . folder_path + \"platform_data.json\" ) with open ( global_data . bl_scene . folder_path + \"platform_data.json\" , \"w\" ) as outfile : json . dump ( global_data . bl_scene . all_data , outfile ) else : if not override : # Create a new filename on the same path try : filename = os . path . basename ( global_data . bl_scene . json_path ) filepath = os . path . dirname ( global_data . bl_scene . json_path ) filename = filename [: re . search ( \"\\d+\" , filename ) . start ()] + str ( int ( re . findall ( \"\\d+\" , filename )[ - 1 ]) + 1 ) + \".json\" global_data . bl_scene . json_path = filepath + \"/\" + filename except : global_data . bl_scene . json_path = os . path . dirname ( global_data . bl_scene . json_path ) + \" \\\\ \" + global_data . bl_scene . json_path . split ( \" \\\\ \" )[ - 1 ] . split ( \".\" )[ - 2 ] + \"_1.json\" with open ( global_data . bl_scene . json_path , \"w\" ) as outfile : json . dump ( global_data . bl_scene . all_data , outfile ) print ( \"Exported\" ) import_label_dict () Imports label dictionary json file from the provided path for label_dict_filepath Source code in Source Code\\main2.py 60 61 62 63 64 65 66 67 68 69 def import_label_dict (): \"\"\" Imports label dictionary json file from the provided path for label_dict_filepath Args: None Returns: None \"\"\" label_file = open ( global_data . bl_scene . label_dict_filepath , \"r\" ) global_data . bl_scene . label_dict = json . loads ( label_file . read ()) read_JSON_data () Reads json file containing all platform, lidar and camera parameters to a given location Source code in Source Code\\main2.py 129 130 131 132 133 134 135 136 137 138 139 def read_JSON_data (): \"\"\" Reads json file containing all platform, lidar and camera parameters to a given location Args: None Returns: None \"\"\" print ( \"Reading file at\" , global_data . bl_scene . json_path ) json_file = open ( global_data . bl_scene . json_path , \"r\" ) global_data . bl_scene . all_data = json . loads ( json_file . read ())","title":"UI"},{"location":"modules/ui/#ui-module","text":"","title":"UI Module"},{"location":"modules/ui/#main2.LIST_OT_DeleteItem","text":"Bases: Operator Delete the selected item from the list. Source code in Source Code\\main2.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 class LIST_OT_DeleteItem ( Operator ): \"\"\"Delete the selected item from the list.\"\"\" bl_idname = \"my_list.delete_item\" bl_label = \"Deletes an item\" @classmethod def poll ( cls , context ): return context . scene . my_list def execute ( self , context ): my_list = context . scene . my_list index = context . scene . list_index my_list . remove ( index ) context . scene . list_index = min ( max ( 0 , index - 1 ), len ( my_list ) - 1 ) return { 'FINISHED' }","title":"LIST_OT_DeleteItem"},{"location":"modules/ui/#main2.LIST_OT_DeleteLabelItem","text":"Bases: Operator Delete the selected item from the list. Source code in Source Code\\main2.py 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 class LIST_OT_DeleteLabelItem ( Operator ): \"\"\"Delete the selected item from the list.\"\"\" bl_idname = \"label_list.delete_item\" bl_label = \"Deletes an label\" @classmethod def poll ( cls , context ): return context . scene . label_list def execute ( self , context ): label_list = context . scene . label_list index = context . scene . label_list_index label_list . remove ( index ) context . scene . label_list_index = min ( max ( 0 , index - 1 ), len ( label_list ) - 1 ) return { 'FINISHED' }","title":"LIST_OT_DeleteLabelItem"},{"location":"modules/ui/#main2.LIST_OT_EmptyLabelList","text":"Bases: Operator Reevaluates the Label list. Source code in Source Code\\main2.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 class LIST_OT_EmptyLabelList ( Operator ): \"\"\"Reevaluates the Label list.\"\"\" bl_idname = \"label_list.emptylist\" bl_label = \"Reevaluates all elements in Label list\" @classmethod def poll ( cls , context ): return context . scene . label_list def execute ( self , context ): label_list = context . scene . label_list index = 0 while ( index < len ( label_list )): label_list . remove ( index ) context . scene . label_list_index = min ( max ( 0 , index - 1 ), len ( label_list ) - 1 ) try : all_objects = bpy . data . collections [ 'Input' ] . all_objects . values () labels = [] for i in all_objects : labels . append ( i . name . split ( \".\" )[ 0 ]) np_label = np . unique ( np . array ( labels )) global_data . bl_scene . label_dict = {} bpy . context . scene . label_list_index = 0 for n in range ( len ( np_label )): global_data . bl_scene . label_dict [ n ] = np_label [ n ] . lower () bpy . context . scene . label_list . add () bpy . context . scene . label_list [ n ] . name = np_label [ n ] . lower () bpy . context . scene . label_list [ n ] . value = str ( n ) bpy . context . scene . label_list_index += 1 return { 'FINISHED' } except : return { 'CANCELLED' }","title":"LIST_OT_EmptyLabelList"},{"location":"modules/ui/#main2.LIST_OT_ExportLabelList","text":"Bases: Operator Exports the Label list. Source code in Source Code\\main2.py 604 605 606 607 608 609 610 611 612 613 614 class LIST_OT_ExportLabelList ( Operator ): \"\"\"Exports the Label list.\"\"\" bl_idname = \"label_list.export\" bl_label = \"Exports all elements in Label list\" def execute ( self , context ): global_data . bl_scene . label_file_path = os . path . dirname ( bpy . data . filepath ) + \"/label_dict.json\" with open ( global_data . bl_scene . label_file_path , \"w\" ) as outfile : json . dump ( global_data . bl_scene . label_dict , outfile ) return { 'FINISHED' }","title":"LIST_OT_ExportLabelList"},{"location":"modules/ui/#main2.LIST_OT_MoveItem","text":"Bases: Operator Move an item in the list. Source code in Source Code\\main2.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 class LIST_OT_MoveItem ( Operator ): \"\"\"Move an item in the list.\"\"\" bl_idname = \"my_list.move_item\" bl_label = \"Move an item in the list\" direction : bpy . props . EnumProperty ( items = (( 'UP' , 'Up' , \"\" ), ( 'DOWN' , 'Down' , \"\" ),)) @classmethod def poll ( cls , context ): return context . scene . my_list def move_index ( self ): \"\"\" Move index of an item render queue while clamping it. \"\"\" index = bpy . context . scene . list_index list_length = len ( bpy . context . scene . my_list ) - 1 # (index starts at 0) new_index = index + ( - 1 if self . direction == 'UP' else 1 ) bpy . context . scene . list_index = max ( 0 , min ( new_index , list_length )) def execute ( self , context ): my_list = context . scene . my_list index = context . scene . list_index neighbor = index + ( - 1 if self . direction == 'UP' else 1 ) my_list . move ( neighbor , index ) self . move_index () return { 'FINISHED' }","title":"LIST_OT_MoveItem"},{"location":"modules/ui/#main2.LIST_OT_MoveItem.move_index","text":"Move index of an item render queue while clamping it. Source code in Source Code\\main2.py 482 483 484 485 486 487 488 489 def move_index ( self ): \"\"\" Move index of an item render queue while clamping it. \"\"\" index = bpy . context . scene . list_index list_length = len ( bpy . context . scene . my_list ) - 1 # (index starts at 0) new_index = index + ( - 1 if self . direction == 'UP' else 1 ) bpy . context . scene . list_index = max ( 0 , min ( new_index , list_length ))","title":"move_index()"},{"location":"modules/ui/#main2.LIST_OT_NewItem","text":"Bases: Operator Add a new item to the list. Source code in Source Code\\main2.py 440 441 442 443 444 445 446 447 448 class LIST_OT_NewItem ( Operator ): \"\"\"Add a new item to the list.\"\"\" bl_idname = \"my_list.new_item\" bl_label = \"Add a new item\" def execute ( self , context ): context . scene . my_list . add () return { 'FINISHED' }","title":"LIST_OT_NewItem"},{"location":"modules/ui/#main2.LIST_OT_NewLabelItem","text":"Bases: Operator Add a new label to list. Source code in Source Code\\main2.py 535 536 537 538 539 540 541 542 543 class LIST_OT_NewLabelItem ( Operator ): \"\"\"Add a new label to list.\"\"\" bl_idname = \"label_list.new_item\" bl_label = \"Add a new label\" def execute ( self , context ): context . scene . label_list . add () return { 'FINISHED' }","title":"LIST_OT_NewLabelItem"},{"location":"modules/ui/#main2.LabelListItem","text":"Bases: PropertyGroup Group of properties representing an label item in the list. Source code in Source Code\\main2.py 501 502 503 504 505 506 507 508 509 510 511 512 513 class LabelListItem ( PropertyGroup ): \"\"\"Group of properties representing an label item in the list.\"\"\" name : StringProperty ( name = \"Name\" , description = \"Object Name\" , default = \"\" ) value : StringProperty ( name = \"Value\" , description = \"\" , default = \"999\" )","title":"LabelListItem"},{"location":"modules/ui/#main2.ListItem","text":"Bases: PropertyGroup Group of properties representing an item in the list. Source code in Source Code\\main2.py 406 407 408 409 410 411 412 413 414 415 416 417 418 class ListItem ( PropertyGroup ): \"\"\"Group of properties representing an item in the list.\"\"\" name : StringProperty ( name = \"Name\" , description = \"A name for this item\" , default = \"List Item\" ) random_prop : StringProperty ( name = \"JSON Path\" , description = \"\" , default = \"*.json\" , subtype = 'FILE_PATH' )","title":"ListItem"},{"location":"modules/ui/#main2.MY_UL_List","text":"Bases: UIList Demo UIList. Source code in Source Code\\main2.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 class MY_UL_List ( UIList ): \"\"\"Demo UIList.\"\"\" def draw_item ( self , context , layout , data , item , icon , active_data , active_propname , index ): # We could write some code to decide which icon to use here... #custom_icon = 'OBJECT_DATAMODE' # Make sure your code supports all 3 layout types if self . layout_type in { 'DEFAULT' , 'COMPACT' }: #layout.label(text=item.name, icon = custom_icon) layout . label ( text = item . name ) layout . label ( text = item . random_prop ) elif self . layout_type in { 'GRID' }: layout . alignment = 'CENTER' #layout.label(text=\"\", icon = custom_icon) layout . label ( text = \"\" )","title":"MY_UL_List"},{"location":"modules/ui/#main2.SCENE_LABEL_List","text":"Bases: UIList Display Labels Source code in Source Code\\main2.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 class SCENE_LABEL_List ( UIList ): \"\"\"Display Labels\"\"\" def draw_item ( self , context , layout , data , item , icon , active_data , active_propname , index ): # We could write some code to decide which icon to use here... #custom_icon = 'OBJECT_DATAMODE' # Make sure your code supports all 3 layout types if self . layout_type in { 'DEFAULT' , 'COMPACT' }: #layout.label(text=item.name, icon = custom_icon) layout . label ( text = item . name ) layout . label ( text = item . value ) elif self . layout_type in { 'GRID' }: layout . alignment = 'CENTER' #layout.label(text=\"\", icon = custom_icon) layout . label ( text = \"\" )","title":"SCENE_LABEL_List"},{"location":"modules/ui/#main2.createNew","text":"Creates a empty json structure for a new platform design Args: sensor_count (int) - Count of the lidar sensors to be added camera_count (int) - Count of the camera sensors to be added Source code in Source Code\\main2.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def createNew ( sensor_count , camera_count ): \"\"\" Creates a empty json structure for a new platform design Args: sensor_count (int) - Count of the lidar sensors to be added camera_count (int) - Count of the camera sensors to be added Returns: None \"\"\" global_data . bl_scene . all_data = { \"platform_data\" :{}, \"sensors\" :{}, \"cameras\" : {} } sensor_data = {} camera_data = {} for sn in range ( 1 , sensor_count + 1 ): sensor_data [ str ( sn )] = {} for cn in range ( 1 , camera_count + 1 ): camera_data [ str ( cn )] = {} global_data . bl_scene . all_data [ \"sensors\" ] = sensor_data global_data . bl_scene . all_data [ \"cameras\" ] = camera_data","title":"createNew()"},{"location":"modules/ui/#main2.delete_platforms","text":"Deletes all pre generated sensor objects Returns: None Source code in Source Code\\main2.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def delete_platforms (): \"\"\"Deletes all pre generated sensor objects Args: self Returns: None \"\"\" try : coll = bpy . data . collections . get ( \"Sensor\" ) obs = [ o for o in coll . objects ] n = len ( obs ) logger . update_progress ( \"Deleting existing platforms\" , 0 ) while obs : logger . update_progress ( \"Deleting existing platforms\" , ( 1 - len ( obs ) / n )) bpy . data . objects . remove ( obs . pop (), do_unlink = True ) except : new_col = bpy . data . collections . new ( name = \"Sensor\" ) bpy . context . scene . collection . children . link ( new_col )","title":"delete_platforms()"},{"location":"modules/ui/#main2.export_json","text":"Exports json file containing all platform, lidar and camera parameters to a given location or overrides a given json file with new data Source code in Source Code\\main2.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def export_json ( override = False ): \"\"\" Exports json file containing all platform, lidar and camera parameters to a given location or overrides a given json file with new data Args: None Returns: None \"\"\" if global_data . bl_scene . folder_path != \"\" : # For Exporting a new JSON file on the given folder path print ( \"Exporting json at\" , global_data . bl_scene . folder_path + \"platform_data.json\" ) with open ( global_data . bl_scene . folder_path + \"platform_data.json\" , \"w\" ) as outfile : json . dump ( global_data . bl_scene . all_data , outfile ) else : if not override : # Create a new filename on the same path try : filename = os . path . basename ( global_data . bl_scene . json_path ) filepath = os . path . dirname ( global_data . bl_scene . json_path ) filename = filename [: re . search ( \"\\d+\" , filename ) . start ()] + str ( int ( re . findall ( \"\\d+\" , filename )[ - 1 ]) + 1 ) + \".json\" global_data . bl_scene . json_path = filepath + \"/\" + filename except : global_data . bl_scene . json_path = os . path . dirname ( global_data . bl_scene . json_path ) + \" \\\\ \" + global_data . bl_scene . json_path . split ( \" \\\\ \" )[ - 1 ] . split ( \".\" )[ - 2 ] + \"_1.json\" with open ( global_data . bl_scene . json_path , \"w\" ) as outfile : json . dump ( global_data . bl_scene . all_data , outfile ) print ( \"Exported\" )","title":"export_json()"},{"location":"modules/ui/#main2.import_label_dict","text":"Imports label dictionary json file from the provided path for label_dict_filepath Source code in Source Code\\main2.py 60 61 62 63 64 65 66 67 68 69 def import_label_dict (): \"\"\" Imports label dictionary json file from the provided path for label_dict_filepath Args: None Returns: None \"\"\" label_file = open ( global_data . bl_scene . label_dict_filepath , \"r\" ) global_data . bl_scene . label_dict = json . loads ( label_file . read ())","title":"import_label_dict()"},{"location":"modules/ui/#main2.read_JSON_data","text":"Reads json file containing all platform, lidar and camera parameters to a given location Source code in Source Code\\main2.py 129 130 131 132 133 134 135 136 137 138 139 def read_JSON_data (): \"\"\" Reads json file containing all platform, lidar and camera parameters to a given location Args: None Returns: None \"\"\" print ( \"Reading file at\" , global_data . bl_scene . json_path ) json_file = open ( global_data . bl_scene . json_path , \"r\" ) global_data . bl_scene . all_data = json . loads ( json_file . read ())","title":"read_JSON_data()"}]}